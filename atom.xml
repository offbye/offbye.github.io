<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>offbye</title>
  <subtitle>关注移动架构，Android，HTML5，iOS技术前沿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://offbye.com/"/>
  <updated>2016-05-12T16:23:41.000Z</updated>
  <id>http://offbye.com/</id>
  
  <author>
    <name>offbye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://offbye.com/2016/05/13/hello-world/"/>
    <id>http://offbye.com/2016/05/13/hello-world/</id>
    <published>2016-05-12T16:23:41.000Z</published>
    <updated>2016-05-12T16:23:41.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YAML文件语法简介</title>
    <link href="http://offbye.com/2016/05/12/YAML%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://offbye.com/2016/05/12/YAML文件语法简介/</id>
    <published>2016-05-12T07:46:53.000Z</published>
    <updated>2016-05-12T16:23:41.000Z</updated>
    
    <content type="html">&lt;p&gt;YAML是一种利于人们读写的数据格式. 现在很多系统例如Spring,Ansible,RoR等都支持YAML配置文件，YAML由于其良好的可读性，越来月流行。此外在大多数变成语言中有使用 YAML 的库.&lt;/p&gt;
&lt;p&gt;这个页面提供一个正确的 YAML 语法的基本概述, 它被用来描述一个 playbooks(我们的配置管理语言).&lt;/p&gt;
&lt;p&gt;#基本的YAML&lt;br&gt;对于 Ansible, 每一个 YAML 文件都是从一个列表开始. 列表中的每一项都是一个键值对, 通常它们被称为一个 “哈希” 或 “字典”. 所以, 我们需要知道如何在 YAML 中编写列表和字典.&lt;/p&gt;
&lt;p&gt;YAML 还有一个小的怪癖. 所有的 YAML 文件(无论和 Ansible 有没有关系)开始行都应该是 —. 这是 YAML 格式的一部分, 表明一个文件的开始.&lt;/p&gt;
&lt;p&gt;列表中的所有成员都开始于相同的缩进级别, 并且使用一个 “- “ 作为开头(一个横杠和一个空格):&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一个美味水果的列表&quot;&gt;&lt;a href=&quot;#一个美味水果的列表&quot; class=&quot;headerlink&quot; title=&quot;一个美味水果的列表&quot;&gt;&lt;/a&gt;一个美味水果的列表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Apple&lt;/li&gt;
&lt;li&gt;Orange&lt;/li&gt;
&lt;li&gt;Strawberry&lt;/li&gt;
&lt;li&gt;Mango&lt;br&gt;一个字典是由一个简单的 键: 值 的形式组成(这个冒号后面必须是一个空格):&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 一位职工的记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name: Example Developer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;job: Developer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;skill: Elite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;字典也可以使用缩进形式来表示, 如果你喜欢这样的话:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 一位职工的记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;name: Example Developer, job: Developer, skill: Elite&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Ansible并不是太多的使用这种格式, 但是你可以通过以下格式来指定一个布尔值(true/fase):&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;create_key: yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;needs_agent: no&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;knows_oop: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;likes_emacs: TRUE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;uses_cvs: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;让我们把目前所学到的 YAML 例子组合在一起. 这些在 Ansible 中什么也干不了, 但这些格式将会给你感觉:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 一位职工记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name: Example Developer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;job: Developer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;skill: Elite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;employed: True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foods:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - Apple&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - Orange&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - Strawberry&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - Mango&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;languages:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ruby: Elite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    python: Elite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dotnet: Lame&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就是你开始编写 Ansible playbooks 所需要知道的所有 YAML 语法.&lt;/p&gt;
&lt;p&gt;Gotchas&lt;br&gt;尽管 YAML 通常是友好的, 但是下面将会导致一个 YAML 语法错误:&lt;/p&gt;
&lt;p&gt;foo: somebody said I should put a colon here: so I did&lt;br&gt;你需要使用引号来包裹任何包含冒号的哈希值, 像这样:&lt;/p&gt;
&lt;p&gt;foo: “somebody said I should put a colon here: so I did”&lt;br&gt;然后这个冒号将会被结尾.&lt;/p&gt;
&lt;p&gt;此外, Ansible 使用 “” 来引用变量. 如果一个值以 “{” 开头, YAML 将认为它是一个字典, 所以我们必须引用它, 像这样:&lt;/p&gt;
&lt;p&gt;foo: ““&lt;/p&gt;
</content>
    
    <summary type="html">
    
      YAML是一种利于人们读写的数据格式. 现在很多系统例如Spring等都支持YAML配置文件，YAML由于其良好的可读性，越来月流行。此外在大多数变成语言中有使用 YAML 的库. 
    
    </summary>
    
    
      <category term="YAML" scheme="http://offbye.com/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>iOS App沙盒模型文件目录详解Swift版</title>
    <link href="http://offbye.com/2016/05/11/iOS-Sandbox-swift/"/>
    <id>http://offbye.com/2016/05/11/iOS-Sandbox-swift/</id>
    <published>2016-05-11T10:25:25.000Z</published>
    <updated>2016-05-12T16:23:41.000Z</updated>
    
    <content type="html">&lt;p&gt;本文会比较全面的介绍iOS App沙盒模型的文件夹及其使用场景，以及通过Swift取得这些文件夹的方法&lt;/p&gt;
&lt;h1 id=&quot;iOS-中的沙盒机制介绍&quot;&gt;&lt;a href=&quot;#iOS-中的沙盒机制介绍&quot; class=&quot;headerlink&quot; title=&quot;iOS 中的沙盒机制介绍&quot;&gt;&lt;/a&gt;iOS 中的沙盒机制介绍&lt;/h1&gt;&lt;p&gt;iOS 中的沙盒机制（SandBox）是一种安全体系。&lt;br&gt;每个iOS 应用程序都有一个单独的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域被称为沙盒。所有的非代码文件都要保存在此，例如属性文件 plist、文本文件、图像、图标、媒体资源等。&lt;/p&gt;
&lt;h1 id=&quot;iPhone沙箱模型的四个文件夹介绍和功能&quot;&gt;&lt;a href=&quot;#iPhone沙箱模型的四个文件夹介绍和功能&quot; class=&quot;headerlink&quot; title=&quot;iPhone沙箱模型的四个文件夹介绍和功能&quot;&gt;&lt;/a&gt;iPhone沙箱模型的四个文件夹介绍和功能&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Documents 目录：您应该将所有de应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。用户自己保存的文件在documents文件里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Library 目录：这个目录下有两个子目录：Caches 和 Preferences&lt;br&gt;Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.&lt;br&gt;Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;补充1：对于上述描述可以这样举例理解，一个记事本应用，用户写的东西需要保存起来，这些东西是用户自行生成的，则需要放在 Documents 目录里。一个新闻应用，如果需要从服务器下载东西展示给用户看，下载的东西就放在 Library/Caches 目录里。苹果审核对这个要求很严格，主要原因是 iCloud 的同步问题。&lt;br&gt;补充2：如果想知道真机或者模拟器 App 沙盒路径，可通过在项目中执行下述代码打印获取：&lt;/p&gt;
&lt;h1 id=&quot;获取这些目录路径的方法&quot;&gt;&lt;a href=&quot;#获取这些目录路径的方法&quot; class=&quot;headerlink&quot; title=&quot;获取这些目录路径的方法&quot;&gt;&lt;/a&gt;获取这些目录路径的方法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;获取Home目录路径的函数：&lt;br&gt;let homeDir = NSHomeDirectory()&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取Documents目录路径的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let paths =  NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.NSDocumentDirectory, NSSearchPathDomainMask.UserDomainMask, true)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let   documentPath = paths[0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取Caches目录路径的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let paths =  NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory,NSSearchPathDomainMask.UserDomainMask, true)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let   cachePath = paths[0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取tmp目录路径的方法：&lt;br&gt;let tmpDir = NSTemporaryDirectory();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;获取应用程序程序包中资源文件路径的方法：&lt;br&gt;程序包（NSBundle）&lt;br&gt;iOS 应用都是通过 bundle 进行封装的，可以狭隘地将 bundle 理解为上述沙盒中的 AppName.app 文件。在 Finder 中，会把 bundle 当做一个文件显示从而防止用户误操作导致程序文件损坏，但其实内部是一个目录，包含了图像、媒体资源、编译好的代码、nib 文件等，这个目录称为 main bundle。&lt;br&gt;Cocoa 提供了 NSBundle 类封装了 bundle 操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过NSBundle可以获取各种资源文件，注意在Build Phases - Copy Bundle Rresources下面需要有这个资源文件，有些类型的文件不会自动加在这里&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let path = NSBundle.mainBundle().pathForResource(&amp;quot;20160504182134006&amp;quot;, ofType: &amp;quot;pcm&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;代码中的mainBundle类方法用于返回一个代表应用程序包的对象。&lt;/p&gt;
&lt;h1 id=&quot;NSFileManager文件管理介绍&quot;&gt;&lt;a href=&quot;#NSFileManager文件管理介绍&quot; class=&quot;headerlink&quot; title=&quot;NSFileManager文件管理介绍&quot;&gt;&lt;/a&gt;NSFileManager文件管理介绍&lt;/h1&gt;&lt;p&gt;使用 FileManager 可以对沙盒中的目录、文件进行操作。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var fm: NSFileManager = NSFileManager.defaultManager()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if !fm.fileExistsAtPath(self.dataFilePath()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //下面是对该文件进行制定路径的保存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fm.createDirectoryAtPath(self.dataFilePath(), withIntermediateDirectories: true, attributes: nil, error: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //取得一个目录下得所有文件名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var files: [AnyObject] = fm.subpathsAtPath(self.dataFilePath())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //读取某个文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var data: NSData = fm.contentsAtPath(self.dataFilePath())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var data: NSData = NSData.dataWithContentOfPath(self.dataFilePath())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      本文会比较全面的介绍iOS App沙盒模型的文件夹及其使用场景，以及通过Swift取得这些文件夹的方法。iOS 中的沙盒机制（SandBox）是一种安全体系。每个iOS 应用程序都有一个单独的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域被称为沙盒。所有的非代码文件都要保存在此，例如属性文件 plist、文本文件、图像、图标、媒体资源等。
    
    </summary>
    
    
      <category term="Sandbox" scheme="http://offbye.com/tags/Sandbox/"/>
    
      <category term="swift" scheme="http://offbye.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS App沙盒模型文件目录详解Swift版</title>
    <link href="http://offbye.com/2016/05/06/iOS%20App%E6%B2%99%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%AF%A6%E8%A7%A3Swift%E7%89%88/"/>
    <id>http://offbye.com/2016/05/06/iOS App沙盒模型文件目录详解Swift版/</id>
    <published>2016-05-06T02:16:00.000Z</published>
    <updated>2016-05-12T16:39:59.000Z</updated>
    
    <content type="html">&lt;p&gt;本文会比较全面的介绍iOS App沙盒模型的文件夹及其使用场景，以及通过swift取得这些文件夹的方法&lt;/p&gt;
&lt;p&gt;##iOS 中的沙盒机制介绍&lt;br&gt;iOS 中的沙盒机制（SandBox）是一种安全体系。&lt;br&gt;每个 iOS 应用程序都有一个单独的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域被称为沙盒。所有的非代码文件都要保存在此，例如属性文件 plist、文本文件、图像、图标、媒体资源等。&lt;/p&gt;
&lt;p&gt;##iPhone沙箱模型的四个文件夹介绍和功能&lt;/p&gt;
&lt;p&gt;1、Documents 目录：您应该将所有de应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。用户自己保存的文件在documents文件里&lt;br&gt;2、AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。&lt;br&gt;3、Library 目录：这个目录下有两个子目录：Caches 和 Preferences&lt;br&gt;Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.&lt;br&gt;Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。&lt;br&gt;4、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。&lt;/p&gt;
&lt;p&gt;补充1：对于上述描述可以这样举例理解，一个记事本应用，用户写的东西需要保存起来，这些东西是用户自行生成的，则需要放在 Documents 目录里。一个新闻应用，如果需要从服务器下载东西展示给用户看，下载的东西就放在 Library/Caches 目录里。苹果审核对这个要求很严格，主要原因是 iCloud 的同步问题。&lt;br&gt;补充2：如果想知道真机或者模拟器 App 沙盒路径，可通过在项目中执行下述代码打印获取：&lt;/p&gt;
&lt;p&gt;##获取这些目录路径的方法&lt;br&gt;1，获取Home目录路径的函数：&lt;br&gt; let homeDir = NSHomeDirectory()&lt;br&gt;2，获取Documents目录路径的方法：&lt;br&gt;let paths =  NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.NSDocumentDirectory, NSSearchPathDomainMask.UserDomainMask, true)&lt;br&gt;let   documentPath = paths[0]&lt;/p&gt;
&lt;p&gt;3，获取Caches目录路径的方法：&lt;br&gt;let paths =  NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.CachesDirectory,NSSearchPathDomainMask.UserDomainMask, true)&lt;br&gt;let   cachePath = paths[0]&lt;/p&gt;
&lt;p&gt;4，获取tmp目录路径的方法：&lt;br&gt;let tmpDir = NSTemporaryDirectory();&lt;br&gt;5，获取应用程序程序包中资源文件路径的方法：程序包（NSBundle）&lt;br&gt;iOS 应用都是通过 bundle 进行封装的，可以狭隘地将 bundle 理解为上述沙盒中的 AppName.app 文件。在 Finder 中，会把 bundle 当做一个文件显示从而防止用户误操作导致程序文件损坏，但其实内部是一个目录，包含了图像、媒体资源、编译好的代码、nib 文件等，这个目录称为 main bundle。&lt;br&gt;Cocoa 提供了 NSBundle 类封装了 bundle 操作。&lt;/p&gt;
&lt;p&gt;通过NSBundle可以获取各种资源文件，注意在Build Phases - Copy Bundle Rresources下面需要有这个资源文件，有些类型的文件不会自动加在这里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let path = NSBundle.mainBundle().pathForResource(&amp;quot;20160504182134006&amp;quot;, ofType: &amp;quot;pcm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码中的mainBundle类方法用于返回一个代表应用程序包的对象。&lt;/p&gt;
&lt;p&gt;##NSFileManager文件管理介绍&lt;br&gt;使用 FileManager 可以对沙盒中的目录、文件进行操作。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;var fm: NSFileManager = NSFileManager.defaultManager()&lt;br&gt;if !fm.fileExistsAtPath(self.dataFilePath()) {&lt;br&gt;    //下面是对该文件进行制定路径的保存&lt;br&gt;    fm.createDirectoryAtPath(self.dataFilePath(), withIntermediateDirectories: true, attributes: nil, error: nil)&lt;br&gt;        //取得一个目录下得所有文件名&lt;br&gt;    var files: [AnyObject] = fm.subpathsAtPath(self.dataFilePath())&lt;br&gt;        //读取某个文件&lt;br&gt;    var data: NSData = fm.contentsAtPath(self.dataFilePath())&lt;br&gt;        //或者&lt;br&gt;    var data: NSData = NSData.dataWithContentOfPath(self.dataFilePath())&lt;br&gt;}&lt;/p&gt;
</content>
    
    <summary type="html">
    
       iOS App沙盒模型文件目录详解Swift版 
    
    </summary>
    
      <category term="ios" scheme="http://offbye.com/categories/ios/"/>
    
      <category term="沙盒" scheme="http://offbye.com/categories/ios/%E6%B2%99%E7%9B%92/"/>
    
      <category term="Swift" scheme="http://offbye.com/categories/ios/%E6%B2%99%E7%9B%92/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift iOS实现把PCM语音转成MP3格式</title>
    <link href="http://offbye.com/2016/05/05/Swift%20iOS%E5%AE%9E%E7%8E%B0%E6%8A%8APCM%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%88%90MP3%E6%A0%BC%E5%BC%8F/"/>
    <id>http://offbye.com/2016/05/05/Swift iOS实现把PCM语音转成MP3格式/</id>
    <published>2016-05-05T10:46:00.000Z</published>
    <updated>2016-05-12T16:39:59.000Z</updated>
    
    <content type="html">&lt;p&gt;最近折腾了swift的语音录制识别和转码，这块还是比较坑的，由于语音识别的准确度实测大概也就80%左右，所以还是需要上传录音文件啊。&lt;br&gt;首先是用讯飞语音SDK实现语音录制和识别（语音听写），第一个坑是讯飞SDK只录制了PCM格式的文件，这个文件是原始格式，默认比较大，另外播放器支持也不好，因此需要先把它转成mp3，本来考虑使用系统的AudioConverter转aac格式，不过aac好像不能在浏览器上播放。&lt;br&gt;转成mp3需要lame库支持，注意国内网搜到的lame.a库不支持64位，所以现在不能用了。&lt;br&gt;还好已经有人做了这个事情，直接提供了最新编译脚本和编译好的framework库，地址是&lt;a href=&quot;https://github.com/wuqiong/mp3lame-for-iOS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wuqiong/mp3lame-for-iOS&lt;/a&gt;&lt;br&gt;我直接用了上面编译的framework，没有自己去编译，直接把lame.framework拖到工程里。&lt;br&gt;然后需要用oc写个封装类，我不确定这个封装类能不能用swift写，毕竟里面用了很多c的语法，还是用oc桥接一层比较保险。oc封装类如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;AudioWrapper.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;lame/lame.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AudioWrapper&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)audioPCMto&lt;span class=&quot;built_in&quot;&gt;MP3&lt;/span&gt; :(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)audioFileSavePath :(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)mp3FilePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; read, write;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FILE *pcm = fopen([audioFileSavePath cStringUsingEncoding:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;rb&quot;&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//source 被转换的音频文件位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fseek(pcm, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;, SEEK_CUR);                                   &lt;span class=&quot;comment&quot;&gt;//skip file header&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FILE *mp3 = fopen([mp3FilePath cStringUsingEncoding:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&quot;wb&quot;&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//output 输出生成的Mp3文件位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; PCM_SIZE = &lt;span class=&quot;number&quot;&gt;8192&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;MP3_SIZE&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;8192&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pcm_buffer[PCM_SIZE*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; mp3_buffer[&lt;span class=&quot;built_in&quot;&gt;MP3_SIZE&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lame_t lame = lame_init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lame_set_in_samplerate(lame, &lt;span class=&quot;number&quot;&gt;11025.0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lame_set_VBR(lame, vbr_default);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lame_init_params(lame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            read = fread(pcm_buffer, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;), PCM_SIZE, pcm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (read == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                write = lame_encode_flush(lame, mp3_buffer, &lt;span class=&quot;built_in&quot;&gt;MP3_SIZE&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, &lt;span class=&quot;built_in&quot;&gt;MP3_SIZE&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fwrite(mp3_buffer, write, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, mp3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (read != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lame_close(lame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fclose(mp3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fclose(pcm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@catch&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSException&lt;/span&gt; *exception) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,[exception description]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;MP3 converted: %@&quot;&lt;/span&gt;,mp3FilePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在桥接文件XXX-Bridging-Header.h中加入&lt;/p&gt;
&lt;p&gt;#import “AudioWrapper.h”&lt;br&gt;最后 swift文件的调用如下:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_async&lt;/span&gt;(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                AudioWrapper.audioPCMtoMP3(path, pathMp3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我觉得在主线程调用容易出问题，就新开了个线程调用，实测没有问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Swift iOS实现把PCM语音转成MP3格式 
    
    </summary>
    
      <category term="swift" scheme="http://offbye.com/categories/swift/"/>
    
      <category term="mp3" scheme="http://offbye.com/categories/swift/mp3/"/>
    
      <category term="lame" scheme="http://offbye.com/categories/swift/mp3/lame/"/>
    
    
  </entry>
  
  <entry>
    <title>RESTFUL API 安全设计</title>
    <link href="http://offbye.com/2016/05/04/RESTFUL%20API%20%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://offbye.com/2016/05/04/RESTFUL API 安全设计/</id>
    <published>2016-05-04T06:22:00.000Z</published>
    <updated>2016-05-12T16:39:59.000Z</updated>
    
    <content type="html">&lt;p&gt;#0x01 REST API 简介&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;REST的全称是REpresentational State Transfer，表示表述性无状态传输，无需session，所以每次请求都得带上身份认证信息。rest是基于http协议的，也是无状态的。只是一种架构方式，所以它的安全特性都需我们自己实现，没有现成的。建议所有的请求都通过https协议发送。RESTful web services 概念的核心就是“资源”。 资源可以用 URI 来表示。客户端使用 HTTP 协议定义的方法来发送请求到这些 URIs，当然可能会导致这些被访问的”资源“状态的改变。HTTP请求对应关系如下：&lt;br&gt;    ==========  =====================  ========================&lt;br&gt;    HTTP 方法   行为                   示例&lt;br&gt;    ==========  =====================  ========================&lt;br&gt;    GET         获取资源的信息         &lt;a href=&quot;http://xx.com/api/orders&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xx.com/api/orders&lt;/a&gt;&lt;br&gt;    GET         获取某个特定资源的信息 &lt;a href=&quot;http://xx.com/api/orders/123&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xx.com/api/orders/123&lt;/a&gt;&lt;br&gt;    POST        创建新资源             &lt;a href=&quot;http://xx.com/api/orders&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xx.com/api/orders&lt;/a&gt;&lt;br&gt;    PUT         更新资源               &lt;a href=&quot;http://xx.com/api/orders/123&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xx.com/api/orders/123&lt;/a&gt;&lt;br&gt;    DELETE      删除资源               &lt;a href=&quot;http://xx.com/api/orders/123&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xx.com/api/orders/123&lt;/a&gt;&lt;br&gt;    ==========  ====================== =======================&lt;/p&gt;
&lt;p&gt;对于请求的数据一般用json或者xml形式来表示，推荐使用json。&lt;/p&gt;
&lt;p&gt;#0x02 身份认证&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;身份认证包含很多种，有HTTP Basic，HTTP Digest，API KEY，Oauth，JWK等方式，下面简单讲解下：&lt;/p&gt;
&lt;p&gt;##2.1 HTTP Basic&lt;br&gt;REST由于是无状态的传输，所以每一次请求都得带上身份认证信息，身份认证的方式，身份认证的方式有很多种，第一种便是http basic，这种方式在客户端要求简单，在服务端实现也非常简单，只需简单配置apache等web服务器即可实现，所以对于简单的服务来说还是挺方便的。但是这种方式安全性较低，就是简单的将用户名和密码base64编码放到header中。&lt;br&gt;    base64编码前：Basic admin:admin&lt;br&gt;    base64编码后：Basic YWRtaW46YWRtaW4=&lt;br&gt;    放到Header中：Authorization: Basic YWRtaW46YWRtaW4=&lt;/p&gt;
&lt;p&gt;正是因为是简单的base64编码存储，切记切记在这种方式下一定得注意使用ssl，不然就是裸奔了。&lt;br&gt;在某些产品中也是基于这种类似方式，只是没有使用apache的basic机制，而是自己写了认证框架，原理还是一样的，在一次请求中base64解码Authorization字段，再和认证信息做校验。很显然这种方式有问题，认证信息相当于明文传输，另外也没有防暴力破解功能。&lt;/p&gt;
&lt;p&gt;##2.2 API KEY&lt;br&gt;API Key就是经过用户身份认证之后服务端给客户端分配一个API Key，类似：&lt;a href=&quot;http://example.com/api?key=dfkaj134,一般的处理流程如下：&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://example.com/api?key=dfkaj134,一般的处理流程如下：&lt;/a&gt;&lt;br&gt;一个简单的设计示例如下：&lt;br&gt;client端：&lt;br&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151016/2015101611045213385client.png&quot; alt=&quot;clint端&quot;&gt;&lt;br&gt;server端：&lt;br&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151016/2015101611045762856server.png&quot; alt=&quot;server端&quot;&gt;&lt;br&gt;client端向服务端注册，服务端给客户端发送响应的api_key以及security_key，注意保存不要泄露，然后客户端根据api_key,secrity_key,timestrap,rest_uri采用hmacsha256算法得到一个hash值sign，构造途中的url发送给服务端。&lt;br&gt;服务端收到该请求后，首先验证api_key,是否存在，存在则获取该api_key的security_key，接着验证timestrap是否超过时间限制，可依据系统成而定，这样就防止了部分重放攻击，途中的rest_api是从url获取的为/rest/v1/interface/eth0,最后计算sign值，完之后和url中的sign值做校验。这样的设计就防止了数据被篡改。&lt;br&gt;通过这种API Key的设计方式加了时间戳防止了部分重放，加了校验，防止了数据被篡改，同时避免了传输用户名和密码，当然了也会有一定的开销。&lt;/p&gt;
&lt;p&gt;##2.3 Oauth1.0a或者Oauth2&lt;br&gt;OAuth协议适用于为外部应用授权访问本站资源的情况。其中的加密机制与HTTP Digest身份认证相比，安全性更高。使用和配置都比较复杂，这里就不涉及了。&lt;/p&gt;
&lt;p&gt;##2.4 JWT&lt;br&gt;JWT 是JSON Web Token，用于发送可通过数字签名和认证的东西，它包含一个紧凑的，URL安全的JSON对象，服务端可通过解析该值来验证是否有操作权限，是否过期等安全性检查。由于其紧凑的特点，可放在url中或者 HTTP Authorization头中，具体的算法就如下图&lt;br&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151016/2015101611045541381jwt.png&quot; alt=&quot;jwt组成图&quot;&gt;&lt;/p&gt;
&lt;p&gt;#0x03 授权&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;身份认证之后就是授权，根据不同的身份，授予不同的访问权限。比如admin用户，普通用户，auditor用户都是不同的身份。简单的示例：&lt;br&gt;12345678910$roles= &lt;strong&gt;array&lt;/strong&gt;(‘ADMIN’=&amp;gt;&lt;strong&gt;array&lt;/strong&gt;(‘permit’=&amp;gt;&lt;strong&gt;array&lt;/strong&gt;(‘/^((\/system\/(clouds|device)$/‘), // 允许访问哪些URL的正则表达式’deny’=&amp;gt;&lt;strong&gt;array&lt;/strong&gt;(‘/^(\/system\/audit)$/‘) // 禁止访问哪些URL的正则表达式),’AUDIT’=&amp;gt;&lt;strong&gt;array&lt;/strong&gt;(‘permit’=&amp;gt;&lt;strong&gt;array&lt;/strong&gt;(‘/^(\/system\/audit)$/‘),//允许访问的URL正则表达式’deny’=&amp;gt;&lt;strong&gt;array&lt;/strong&gt;(‘/^((\/system\/(clouds|device).*)$/‘)));上述是垂直权限的处理，如果遇到了平行权限的问题，如用户A获取用户B的身份信息或者更改其他用户信息，对于这些敏感数据接口都需要加上对用户的判断，这一步一般都在具体的逻辑实现中实现。&lt;/p&gt;
&lt;p&gt;#0x04 URL过滤&lt;br&gt;在进入逻辑处理之前，加入对URL的参数过滤，如/site/{num}/policy 限定num位置为整数等，如果不是参数则直接返回非法参数，设定一个url清单，不在不在url清单中的请求直接拒绝，这样能防止开发中的api泄露。rest api接口一般会用到GET,POST,PUT,DELETE,未实现的方法则直接返回方法不允许，对于POST，PUT方法的数据采用json格式，并且在进入逻辑前验证是否json，不合法返回json格式错误。&lt;/p&gt;
&lt;p&gt;#0x05 重要功能加密传输&lt;br&gt;第一步推荐SSL加密传输，同时对于系统中重要的功能做加密传输，如证书，一些数据，配置的备份功能，同时还得确保具备相应的权限，这一步会在授权中涉及。&lt;/p&gt;
&lt;p&gt;#0x06 速率限制&lt;br&gt;请求速率限制，根据api_key或者用户来判断某段时间的请求次数，将该数据更新到内存数据库（redis，memcached），达到最大数即不接受该用户的请求，同时这样还可以利用到内存数据库key在特定时间自动过期的特性。在php中可以使用APC，Alternative PHP Cache (APC) 是一个开放自由的PHP opcode 缓存。它的目标是提供一个自由、 开放，和健全的框架用于缓存和优化PHP的中间代码。在返回时设置X-Rate-Limit-Reset:当前时间段剩余秒数，APC的示例代码如下：&lt;br&gt;12345678910111213Route::filter(‘api.limit’, &lt;strong&gt;function&lt;/strong&gt;(){$key= sprintf(‘api:%s’, Auth::user()-&amp;gt;api_key);// Create the key if it doesn’t existCache::add($key, 0, 60);// Increment by 1$count= Cache::increment($key);// Fail if hourly requests exceeded&lt;strong&gt;if&lt;/strong&gt;($count&amp;gt; Config::get(‘api.requests_per_hour’)){App::abort(403, ‘Hourly request limit exceeded’);}});#0x07 错误处理&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于非法的，导致系统出错的等请求都进行记录，一些重要的操作，如登录，注册等都通过日志接口输出展示。有一个统一的出错接口，对于400系列和500系列的错误都有相应的错误码和相关消息提示，如401：未授权；403：已经鉴权，但是没有相应权限。如不识别的url:{“result”:”Invalid URL!”},错误的请求参数{“result”:”json format error”},不允许的方法：{“result”:”Method Not Allowed”}，非法参数等。上面所说的都是单状态码，同时还有多状态码，表示部分成功，部分字符非法等。示例如下：&lt;br&gt;    HTTP/1.1 207 Multi-Status&lt;br&gt;    Content-Type: application/json; charset=”UTF-8”&lt;br&gt;    Content-Length: XXXX    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
&amp;quot;OPT_STATUS&amp;quot;: 207
&amp;quot;DATA&amp;quot;: {
    &amp;quot;IP_ADDRESS&amp;quot;: [{
        &amp;quot;INTERFACE&amp;quot;: &amp;quot;eth0&amp;quot;,
        &amp;quot;IP_LIST&amp;quot;:[{
             &amp;quot;IP&amp;quot;: &amp;quot;192.168.1.1&amp;quot;,
             &amp;quot;MASK&amp;quot;: &amp;quot;255.255.0.0&amp;quot;,
&amp;quot;MULTI_STATUS&amp;quot;: 200,
             &amp;quot;MULTI_RESULT&amp;quot;: &amp;quot;created successfully&amp;quot;
        },{
             &amp;quot;IP&amp;quot;: &amp;quot;192.167.1.1&amp;quot;,
             &amp;quot;MASK&amp;quot;: &amp;quot;255.255.0.0&amp;quot;,
&amp;quot;MULTI_STATUS&amp;quot;: 409,
             &amp;quot;MULTI_RESULT&amp;quot;: &amp;quot;invalid parameter&amp;quot;
}]
}]
},
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#0x08 重要ID不透明处理&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在系统一些敏感功能上，比如/user/1123 可获取id=1123用户的信息，为了防止字典遍历攻击，可对id进行url62或者uuid处理，这样处理的id是唯一的，并且还是字符安全的。&lt;/p&gt;
&lt;p&gt;#0x09 其他注意事项&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;（1）请求数据，对于POST,DELETE方法中的数据都采用json格式，当然不是说rest架构不支持xml，由于xml太不好解析，对于大部分的应用json已经足够，近一些的趋势也是json越来越流行，并且json格式也不会有xml的一些安全问题，如xxe。使用json格式目前能防止扫描器自动扫描。&lt;br&gt;（2）返回数据统一编码格式，统一返回类型，如Content-Type: application/json; charset=”UTF-8”&lt;br&gt;（3）在逻辑实现中，json解码之后进行参数验证或者转义操作，第一步json格式验证，第二步具体参数验证基本上能防止大部分的注入问题了。&lt;br&gt;（4）在传输过程中，采用SSL保证传输安全。&lt;br&gt;（5）存储安全，重要信息加密存储，如认证信息hash保存。&lt;br&gt;总之，尽量使用SSL。&lt;/p&gt;
</content>
    
    <summary type="html">
    
       RESTFUL API 安全设计 
    
    </summary>
    
      <category term="REST" scheme="http://offbye.com/categories/REST/"/>
    
      <category term="安全" scheme="http://offbye.com/categories/REST/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 Token，你应该知道的十件事</title>
    <link href="http://offbye.com/2016/05/04/%E5%85%B3%E4%BA%8E%20Token%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E5%8D%81%E4%BB%B6%E4%BA%8B/"/>
    <id>http://offbye.com/2016/05/04/关于 Token，你应该知道的十件事/</id>
    <published>2016-05-04T06:16:00.000Z</published>
    <updated>2016-05-12T16:40:00.000Z</updated>
    
    <content type="html">&lt;p&gt;原文是一篇很好的讲述 Token 在 Web 应用中使用的&lt;a href=&quot;https://auth0.com/blog/2014/01/27/ten-things-you-should-know-about-tokens-and-cookies/#token-storage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;，而这是我和 &lt;a href=&quot;http://www.specyci.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Special&lt;/a&gt; 合作翻译的译文。&lt;/p&gt;
&lt;p&gt;#1. Token 应该被保存起来（放到 local / session stograge 或者 cookies）&lt;br&gt;在单页应用程序中，有些用户刷新浏览器后会带来一些跟 token 相关的问题。而解决方法很简单：你应该把 token 保存到起来：&lt;a href=&quot;https://github.com/auth0/angular-token-auth/blob/master/auth.client.js#L31&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;放到 session storage, local storage 或者是客户端的 cookie 里&lt;/a&gt;。而浏览器不支持 session storage 时都应该转存到 cookies 里。&lt;br&gt;如果你想“我把 token 保存到 cookie ，不就跟以前没有任何分别？”。可是在这种情况下你只是把 cookie 当作一个储存机制，而不是一种&lt;a href=&quot;http://sitr.us/2011/08/26/cookies-are-bad-for-you.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;验证机制&lt;/a&gt;。（比如说，这个 cookie 不会被 Web 框架用于用户验证，所以没有 XSRF 攻击的危险）。&lt;/p&gt;
&lt;p&gt;#2. Tokens 除了像 cookie 一样有有效期，而且你可以有更多的操作方法&lt;br&gt;Tokens 应该有一个有效期（在 &lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-15#section-4.1.4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JSON Web Tokens&lt;/a&gt; 中是作为 exp 属性），否则其他人只要登录过一次就可以永远地通过 API 的验证。Cookies 基于同样的理由也有一个有效期。&lt;br&gt;在 Cookies 的使用中，有不同的选项可以控制 cookie 的生命周期：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. cookies 可以在浏览器关闭后删除（session cookies）；

2. 另外你可以实现服务器端的检查（通常由你使用的 Web 框架完成），还有也可以实现绝对有效期或弹性有效期（sliding window expiration）；

3. Cookies 可以带有有效期地保存起来（浏览器关闭后也不删除）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在 tokens 的使用中，一旦 token 过期，只需要重新获取一个。你可以使用一个接口去刷新 token：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 让旧的 token 失效；

2. 检查这个用户是不是还存在，权限是否被取消或者任何对你的程序来说是有必要的；

3. 得到一个更新了有效期的 token。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你甚至可以把 token 原来的发布时间也保存起来，并且强制在两星期后重新登录什么的。&lt;br&gt;    1&lt;br&gt;    2&lt;br&gt;    3&lt;br&gt;    4&lt;br&gt;    5&lt;br&gt;    6&lt;br&gt;    7&lt;br&gt;    8&lt;br&gt;    9&lt;br&gt;    10&lt;br&gt;    11&lt;br&gt;    12&lt;br&gt;    13&lt;br&gt;    14&lt;br&gt;    15&lt;br&gt;    16&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.post(&amp;apos;/refresh_token&amp;apos;,function(req,res){// verify the existing tokenvarprofile=jwt.verify(req.body.token,secret);// if more than 14 days old, force loginif(profile.original_iat-newDate()&amp;gt;14){// iat == issued atreturnres.send(401);// re-logging}// check if the user still exists or if authorization hasn&amp;apos;t been revokedif(!valid)returnres.send(401);// re-logging// issue a new tokenvarrefreshed_token=jwt.sign(profile,secret,{expiresInMinutes:60*5});res.json({token:refreshed_token});});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你需要撤回 tokens（当 token 的生存期比较长的时候这很有必要）那么你需要一个 token 的生成管理器去作检查。&lt;/p&gt;
&lt;p&gt;#3. Local / session storage 不会跨域工作，请使用一个标记 cookie&lt;br&gt;如果你设置一个 cookie 的域名为 .yourdomain.com 它将可以被 youdomain.com 和 app.yourdomain.com 获取，这样用户登录并且转到app.yourdomain.com 后也能很容易地从主域名找回这个 cookie（假如你的是电商网站）。&lt;br&gt;而另一方面，保存在 local / session storage 的 tokens，就不能从不同的域名中读取（甚至是子域名也不行）。那你能怎么做？&lt;br&gt;一个可能的选择是，当用户通过 app.yourdomain.com 上面的验证时你生成一个 token 并且作为一个 cookie 保存到 .yourdomain.com&lt;br&gt;    1&lt;br&gt;    2&lt;br&gt;    3&lt;br&gt;    4&lt;br&gt;    5&lt;br&gt;    6&lt;br&gt;    7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.post(&amp;apos;/authenticate, function() {  // store token on local/session storage or cookie    ....  // create a cookie signaling that user is logged in  $.cookie(&amp;apos;loggedin&amp;apos;, profile.name, &amp;apos;.yourdomain.com&amp;apos;);});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，在 youromdain.com 中你可以检查这个 cookie 是不是已经存在了，并且如果存在的话就转到 app.youromdain.com去。从这以后，这个 token 将会对程序的子域名以及之后通常的流程都有效（直到这个 token 超过有效期）。&lt;br&gt;不过这将会导致 cookie 存在但 token 被删除了或其他意外情况的发生。在这种情况下，用户将不得不重新登录。但重要的是，像我们之前说的，我们不会这个用 cookie 作为验证方法，只是作为一个存储机制去支持存储信息在不同的域名中。&lt;/p&gt;
&lt;p&gt;#4. 每个 CORS（跨域资源共享）请求都会带上预请求（Preflight request）&lt;br&gt;有些人指出 Authorization header 不是一个&lt;a href=&quot;http://www.w3.org/TR/cors/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;simple header&lt;/a&gt;，因此对于一个特定的 URLs 的所有请求都会带上一个预请求。&lt;br&gt;    1&lt;br&gt;    2&lt;br&gt;    3&lt;br&gt;    4&lt;br&gt;    5&lt;br&gt;    6&lt;br&gt;    7&lt;br&gt;    8&lt;br&gt;    9&lt;br&gt;    10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OPTIONShttps://api.foo.com/barGEThttps://api.foo.com/barAuthorization:Bearer....OPTIONShttps://api.foo.com/bar2GEThttps://api.foo.com/bar2Authorization:Bearer....GEThttps://api.foo.com/barAuthorization:Bearer....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但这只会发生在你发送 Content-Type: application/json 时。不过这说明已经出现在绝大多数的程序中了。&lt;br&gt;一个小小的警告，the OPTIONS 请求不会带有 Authorization header 自身，所以你的网络框架应该支持区别对待 OPTISON 和后来的请求。（微软的 IIS 因为某些原因好像会有问题）。&lt;/p&gt;
&lt;p&gt;#5. 当你需要流传送某些东西，请用 token 去获取一个已签名的请求。&lt;br&gt;当使用 cookies 时，你可以很容易开始一个文件的下载或流传送内容。然而，在 tokens 的使用中，请求是通过 XHR 完成的，你不能依赖于它。而解决方法应该是像 AWS 那样通过生成一个签名了的请求，例如，Hawk Bewits 是一个很好的框架去启用它：&lt;br&gt;Request:&lt;br&gt;    1&lt;br&gt;    2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST/download-file/123Authorization:Bearer...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Response:&lt;br&gt;    1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ticket=lahdoiasdhoiwdowijaksjdoaisdjoasidja
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个 ticket 是无状态并且是基于 URL 的：host + path + query + headers + timestamp + HMAC，并且有一个有效期。所以它可以用于像只能在5分钟内去下载一个文件。&lt;br&gt;你然后可以转到 /download-file/123? ticket=lahdoiasdhoiwdowijaksjdoaisdjoasidja 中去。服务器就会检查这个 ticket 是不是有效然后像正常一样开始下一步的服务。&lt;/p&gt;
&lt;p&gt;#6. &lt;a href=&quot;http://baike.baidu.com/view/50325.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XSS&lt;/a&gt; 比 &lt;a href=&quot;http://baike.baidu.com/view/1609487.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XSRF&lt;/a&gt; 要更容易防范&lt;br&gt;XSS 攻击的原理是，攻击者插入一段可执行的 JavaScripts 脚本，该脚本会读出用户浏览器的 cookies 并将它传输给攻击者，攻击者得到用户的 Cookies 后，即可冒充用户。但是要防范 XSS 也很简单，在写入 cookies 时，将 HttpOnly 设置为 true，客户端 JavaScripts 就无法读取该 cookies 的值，就可以有效防范 XSS 攻击。因为 Tokens 也是储存在本地的 session storage 或者是客户端的 cookies 中，也是会受到 XSS 攻击。所以在使用 tokens 的时候，必须要考虑过期机制，不然攻击者就可以永久持有受害用户帐号。&lt;br&gt;相比 XSS，XSRF 的危害性更大，因为大多数 Web 框架都已经内置了 XSS 防范机制（例如在 Ruby on Rails 中，用户的输入在输出的时候都会做转义操作，攻击者插入的脚本就无法执行），对于大部分开发者而言，甚至连 XSRF 都不知道是什么玩意，更别提防范了。XSRF 目前并不是每个 Web 框架都有防范机制，因此开发者更应该留意 XSRF 。&lt;/p&gt;
&lt;p&gt;#7. 注意 token 的大小&lt;br&gt;Token 机制在每次请求 API 的时候，都需要带上一个 Authorization 的 Http Header 。&lt;br&gt;    1&lt;br&gt;    2&lt;br&gt;    3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#TokenGET/fooAuthorization:Bearer...2kbtoken...
1
2
3

#CookieGET/fooconnect.sid:...20bytescookie...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Token 的大小其实由你储存在 token 中的信息量所决定，例如可能有 nickname，openid 等开发者另外加上的信息。&lt;br&gt;但是 session cookies 机制只需要一个字串作为用户标识即可（例如 PHP 的 PHPSESSIONID），其中关于用户的信息都会直接储存到服务端的数据库中，当用户请求时才从数据库中捞出来用。&lt;br&gt;当然 Token 机制也可以仿照 session cookies 机制这么做了，也是个有效控制 token 大小的方法。&lt;br&gt;Token 中只保留关键的几条身份标识信息，其余都放到数据库里面了，权限控制的时候再捞出。这样做的好处是，开发者可以完全掌控 token，因为关键信息都已经是你代码和数据库中的一部分了，想怎么弄都可以了。&lt;br&gt;举个例子：&lt;br&gt;    1&lt;br&gt;    2&lt;br&gt;    3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET/fooAuthorization:Bearer……500bytestoken….Thenontheserver:
1
2
3
4
5
6
7
8
9
10

app.use(&amp;apos;/api&amp;apos;,// 首先检查 token；expressJwt({secret:secret}),// 然后再从数据库中捞出用户信息。function(req,res,next){req.user.extra_data=get_from_db();next();});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外值得一提的是，你也可以把东西都丢 Cookies 里面（而不是只丢个身份标识字串）。只要确保资料经过了严格的加密，攻击者无法利用，现在有些 Web 框架已经有类似机制，例如 Nodejs 的这个插件 &lt;a href=&quot;https://github.com/mozilla/node-client-sessions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mozilla/node-client-sessions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;#8. 有需要的话，要加密并且签名 token&lt;br&gt;虽然 TLS/SSL 机制可以隔绝大多数中间人攻击，但是如果 token 中带有了用户的敏感信息，开发者也应该要加密这些信息。&lt;br&gt;使用 JWT（文中第 9 点） 可以加密 token，但是由于目前大多数 Web 框架还未支持 JWT，所以可以使用 AES-CBC 算法加密 token。&lt;br&gt;    1&lt;br&gt;    2&lt;br&gt;    3&lt;br&gt;    4&lt;br&gt;    5&lt;br&gt;    6&lt;br&gt;    7&lt;br&gt;    8&lt;br&gt;    9&lt;br&gt;    10&lt;br&gt;    11&lt;br&gt;    12&lt;br&gt;    13&lt;br&gt;    14&lt;br&gt;    15&lt;br&gt;    16&lt;br&gt;    17&lt;br&gt;    18&lt;br&gt;    19&lt;br&gt;    20&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.post(&amp;apos;/authenticate&amp;apos;,function(req,res){// 校验用户；// 加密 token；varencrypted={token:encryptAesSha256(&amp;apos;shhhh&amp;apos;,JSON.stringify(profile))};// 给加密后的 token 签名；vartoken=jwt.sign(encrypted,secret,{expiresInMinutes:60*5});res.json({token:token});}functionencryptAesSha256(password,textToEncrypt){varcipher=crypto.createCipher(&amp;apos;aes-256-cbc&amp;apos;,password);varcrypted=cipher.update(textToEncrypt,&amp;apos;utf8&amp;apos;,&amp;apos;hex&amp;apos;);crypted+=cipher.final(&amp;apos;hex&amp;apos;);returncrypted;}// 上面就是 encrypt-then-MAC （加密后签名）做法。 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然你也可以用文中的第 7 点，直接将敏感信息丢数据库中。&lt;/p&gt;
&lt;p&gt;#9. 将 JSON Web Tokens 应用到 OAuth 2&lt;br&gt;OAuth 2 是一个解决身份验证的授权协议，并且广泛地使用了 token 。&lt;br&gt;用户通过 OAuth 2 协议授权第三方应用权限，然后服务器返回一个 access_token 给第三方应用，通常也带有 scope 参数，第三方应用通过带上access_token 请求服务器，可以在授权范围（scope）内调用 API。&lt;br&gt;一般来说，类似这种 token 是不透明的，就是核心数据都储存以 hash-table 结果储存在服务器中，客户端只持有一个令牌（access_token），任何人都可以用这个令牌在授权范围（scope）内调用服务器端的 API。&lt;br&gt;Signed tokens（例如 &lt;a href=&quot;http://jwt.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JWT&lt;/a&gt;)）和这种形式的 token 最主要的区别是，JWT 是无状态的，它不储存在服务端 hash-table 中，服务端中不保留 JWT 请求的相关信息，JWT 会把授权信息和 API 调用返回都丢一起返回给客户端。&lt;br&gt;JWT 通常以 Base64 + AES 方式编码传输。OAuth 2 协议也支持 JWT，因为 OAuth 2 并未限制 access_token 数据格式，你可以将 JWT 应用在 OAuth 2 上。&lt;/p&gt;
&lt;p&gt;#10. Tokens 不是万能的解决方法，得根据你的需求自行采用&lt;br&gt;这些年来，我们帮助过不少大公司实现了他们的以 Token 为基础的验证授权架构。曾经有一家 10k + 员工，有着大量数据的公司，他们想实现一个中央权限管理系统，其中有一个需要是某个员工只能读取某个国家某个医院某个床位的id和name字段数据，想想这样的细粒度的权限管理是多么难实现，无论是技术上还是行政上。&lt;br&gt;当然采用 tokens 与否，得看大家的具体需求，但是，要忠告大家的是，不要什么内容都写到 tokens 了，加之前想想有没有这个必要&lt;/p&gt;
&lt;p&gt;原文 &lt;a href=&quot;https://ruby-china.org/topics/7343&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://ruby-china.org/topics/7343&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       关于 Token，你应该知道的十件事 
    
    </summary>
    
      <category term="token" scheme="http://offbye.com/categories/token/"/>
    
      <category term="oauth" scheme="http://offbye.com/categories/token/oauth/"/>
    
      <category term="jwt" scheme="http://offbye.com/categories/token/oauth/jwt/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员的成长和代码行数的关系</title>
    <link href="http://offbye.com/2016/05/04/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%88%90%E9%95%BF%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://offbye.com/2016/05/04/程序员的成长和代码行数的关系/</id>
    <published>2016-05-04T04:39:00.000Z</published>
    <updated>2016-05-12T16:40:00.000Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章很有价值，看了这个文章后马上针对一个架构问题做了决定，在2种方案里面选了只增加线性复杂度的那个。&lt;br&gt;在2011年John D. Cook写了一篇&lt;a href=&quot;http://www.johndcook.com/blog/2011/11/22/norris-number/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;，其中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的朋友Clift Norris发现了一个基本常数，我称之为Norris常数，一个未经培训的程序员在他或她遇到瓶颈之前能写出的平均代码量。Clift估计这个值是1500行。超过这个数以后，代码会变得如此混乱，以至于本人都无法轻而易举的进行调试和修改。&lt;br&gt;我还不了解足够多的初级程序员来验证这一结果，不过我自己认识到，程序员生涯的下一个瓶颈将发生在20,000行。我把Norris常数改成2,000那样正好变成十倍。&lt;br&gt;在我离开大学之后的第一份工作中，我和我的同事一样（和我差不多年纪）反复遇到了20,000行的瓶颈。在梦工厂我们有950个程序给动画师使用，行数统计显示多的一些基本在20,000 至25,000行。超过这个数的话即再多的努力也无法增加新特性了。&lt;br&gt;在1996年年中的时候我负责编写&lt;a href=&quot;http://www.teamten.com/lawrence/oscar/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;梦工厂的照明工具&lt;/a&gt;（和另外两个程序员），我知道这将远远超过20,000行代码。我改变了我的编程方法并且这个工具一年后以大约200,000行的代码量成功交付。 （这个工具计划于2013年退役，在16年时间里它被每天使用并用来拍摄了21部电影。）我因为写了好几个行数在10万到20万的程序，我很确定我遇到了下一个瓶颈，我已经能够能感觉到它。&lt;br&gt;特别难的部分是和一些没有像你一样打破了好几道瓶颈的人讨论技术。打破这些瓶颈意味着做出不同的取舍，特别是一些短期内看起来不合理但以后会有所帮助决定。这很难去争论，短期内的优点是显而易见的，但我无法说服任何人说从现在起一年内可能有人会做出一个看似无害但是会破坏现有代码的改动。&lt;br&gt;Edsger Dijkstra 在1969年&lt;a href=&quot;http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;写道&lt;/a&gt;：&lt;br&gt;一个一岁多的孩子会以一定的速度匍匐前进，比如说每小时一英里。但每小时一千英里的速度就是一架超音速喷气机。就物体的移动能力而言这两者是没有可比性的，任何其中一个可以到的但是另一个不能做到，反之亦然。&lt;br&gt;一个Clift 所指的初级程序员，学会了爬行，接着蹒跚学步，然后行走，然后慢跑，然后再跑步，最后冲刺，他认为，“以这样加速度前进我可以赶上超音速喷气机的速度！“但他跑进了2,000行的极限，因为他的技能不会再按比例增加。他必须改变移动方式，比如开车去获得更快的速度。然后，他就学会了开车，开始很慢，然后越来越快，但有进入到了20000行极限。驾驶汽车的技术不会变成开喷气式飞机。&lt;br&gt;我的朋友&lt;a href=&quot;http://www.plunk.org/~grantham/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Brad Grantham&lt;/a&gt;用新手程序员用“蛮力”解决问题来说明了这一点。我认为这是正确的：当代码是在2,000行以下，你可以写任何混乱肮脏的代码并依靠你的记忆拯救你。深思熟虑的类和包分解会让你的代规模达到20,000行。&lt;br&gt;突破这个瓶颈的关键是什么？对我而言，就是让事情保持简单。除非现在就非常需要，否则完全拒绝添加任何新特性或者新代码。我已经在&lt;a href=&quot;http://www.teamten.com/lawrence/writings/every_line_is_a_potential_bug.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Every Line Is a Potential Bug&lt;/a&gt;中提高了这一点（在&lt;a href=&quot;http://www.teamten.com/lawrence/writings/plan03.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Simple is Good&lt;/a&gt;之前还是一知半解）。梦工厂的首席特效架构师是这么理解的：&lt;br&gt;对我而言，照明工具成功的地方在于他选择了一系列容易使用和维护的小功能并且强大到足够成为一个非常棒的照明工具。&lt;br&gt;作为一名技术领导我明白我主要的贡献是对那些同事觉得非常重要但不能证明其合理的需求说“不”。但真正的诀窍是知道什么需求增加了线性的复杂度（只和自身相关）和指数级复杂度（和别的需求有关联）。两者都因该去避免，但后者需要更令人信服的理由。&lt;br&gt;举个例子，在2012年，Linux内核有&lt;a href=&quot;http://www.h-online.com/open/news/item/Linux-kernel-exceeds-15-million-lines-of-code-1409952.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1500万行代码&lt;/a&gt;。其中75％是具有线性复杂度的（驱动，文件系统和处理器结构相关的代码）。你可能有许多视屏驱动，但他们之间没有任何（或很少）的交互。剩下的则有更多的依赖关系。&lt;br&gt;Dijkstra觉得很难去教授这些先进的方法，因为他们只对那些2万行或者20万行的程序才有意义。任何的类或者规范必须限制其示例在几百行以内，暴力方法在这里也同样适用。你真的需要范例给你显示30,000行代码然后证实因为程序上手并不是非常复杂所以新功能能够很容易的被添加。但这实际上是不可能的。.&lt;br&gt;我不知道做出什么改变来突破20万行的瓶颈。我最近已经切换到了更纯粹的函数式风格并减少了可变状态，也许这些能让我有所突破。&lt;br&gt;而且我很想知道到代码量达到2000万行的时候会变成什么样子。&lt;br&gt;在三百万到四百万行代码左右似乎有一道无形的墙，无论多少人（数以百计）或多少年（数十年）花在上面增长率将会显著降低。－&lt;a href=&quot;https://plus.google.com/u/0/107919048662113456495/posts/AyGGqF9mLdB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dan Wexler&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
       程序员的成长和代码行数的关系 
    
    </summary>
    
      <category term="架构" scheme="http://offbye.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="架构师" scheme="http://offbye.com/categories/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
      <category term="复杂度" scheme="http://offbye.com/categories/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%B8%88/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>从JavaAndroid到Swift iOS开发：语言与框架对比</title>
    <link href="http://offbye.com/2016/05/04/%E4%BB%8EJavaAndroid%E5%88%B0Swift%20iOS%E5%BC%80%E5%8F%91%EF%BC%9A%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
    <id>http://offbye.com/2016/05/04/从JavaAndroid到Swift iOS开发：语言与框架对比/</id>
    <published>2016-05-04T02:48:00.000Z</published>
    <updated>2016-05-12T16:40:00.000Z</updated>
    
    <content type="html">&lt;p&gt;本文是我在『移动前线』微信群2016年4月28日的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;amp;mid=2651112156&amp;amp;idx=1&amp;amp;sn=8dfaa630e8bc6ef66b4263bffd2d29dc&amp;amp;scene=1&amp;amp;srcid=0429FvoQr642MP2BZ5cSMynm&amp;amp;from=singlemessage&amp;amp;isappinstalled=0#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分享总结&lt;/a&gt;整理。&lt;br&gt;我从2009年开始做Android开发，开始接触Swift是在2014年底，当时组里曾经做过一个Demo App，感觉技术还不够成熟没有正式发布。2016年初我们正式使用swift开发上线了销售助手App产品，积累了比较丰富的swift项目实战经验，开源框架都是用的swift版本，大量使用了面向协议和函数式编程。iOS App开发人员基本都是以前安卓版本的开发人员，同时维护安卓和iOS 2个版本，效率很高。&lt;br&gt;今天分享的主题是Java/Android开发人员如何快速上手Swift iOS开发。主要内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WhyFrom Java/Android to Swift&lt;/li&gt;
&lt;li&gt;Swift语言为什么值得学习？&lt;/li&gt;
&lt;li&gt;Javavs Swift语法比较&lt;/li&gt;
&lt;li&gt;Android和iOS UI开发比较&lt;/li&gt;
&lt;li&gt;Androidvs Swift iOS框架比较&lt;/li&gt;
&lt;li&gt;开发工具比较&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##1、Why FromJava/Android to Swift&lt;br&gt;成本和效率方面，由于目前同业务的Android和iOS App产品功能一致，由一个团队开发可以降低业务同步和沟通成本，避免安卓和iOS两个团队带来的产品功能差异和沟通成本。&lt;br&gt;Swift语法更接近Java，相对Objective C上手容易，我2012年曾经带过iOS项目，学过oc，因为无法忍受oc奇怪的语法最后放弃了，但这次学习swift iOS过程还是挺顺畅的，学习的主要门槛反而是Xcode IB的使用。&lt;br&gt;Whynot React Native？&lt;br&gt;ReactNative我们也要项目在用。但RN思想和语法的学习曲线有些陡，很多有Web开发经验的人都不一定喜欢。另外很多安卓开发者并没有学习过js，学习React Native成本会比较高。学习React Native最终还是要对原生开发有一定的了解。最后，在一些功能复杂的App，React Native用户体验比不上原生 。&lt;/p&gt;
&lt;p&gt;Whynot HTML5 Hybrid App？&lt;br&gt;用户体验不够好，对于不熟悉Web开发的工程师学习成本比较高。&lt;br&gt;2014年我们用ionic框架做过混合App，在iOS上效果可以，但在安卓低端机上比较卡，影响用户体验。&lt;/p&gt;
&lt;p&gt;##2、Swift语言为什么值得学习？&lt;br&gt;Swift是现在Apple主推的语言，2014年新推出的语言，比Scala等“新”语言还要年轻10岁。2015年秋已经开源。目前在linux上可用，最近已经支持Android NDK；在树莓派上有SwiftyGPIO库，可以通过GPIO控制一些硬件。&lt;br&gt;ObjectC is old and ugly，oc是1983年苹果推出的，过于陈旧和臃肿。&lt;br&gt;Swift语法类似Scala，Javascript ES6， Java，OC， C++， Python，这个我是按照语法相似度排序的。&lt;br&gt;Swift支持多范式编程：面向协议，面向对象和函数式编程 。&lt;br&gt;最后，我们还可以通过Swift学习函数式编程思想，这块Java8才支持。&lt;/p&gt;
&lt;p&gt;##3、Java vs. Swift语法比较&lt;br&gt;l 基础语法&lt;br&gt;l 函数&lt;br&gt;l struct和class&lt;br&gt;l Enum&lt;br&gt;l Interface vsProtocol&lt;br&gt;l MultiThread&lt;/p&gt;
&lt;p&gt;3.1基础语法&lt;/p&gt;
&lt;p&gt;Java&lt;br&gt;Swift&lt;br&gt;static final 常量&lt;br&gt;Java语言没有，Guava库提供&lt;br&gt;Java支持自增++，自减—&lt;br&gt;逻辑控制和C基本一致&lt;br&gt;Java有main方法&lt;br&gt;Java需要;做行结束符&lt;br&gt;var 变量，let常量&lt;br&gt;可选型Optional，通过if let解包&lt;br&gt;Swift不建议使用，3.0版本将不支持自增&lt;br&gt;逻辑控制语句更现代&lt;br&gt;Swift没有main方法&lt;br&gt;Swift不需要行结束符&lt;br&gt;Swift的switch 语法和Java及C++很像，但是它没有break，他命中一个case后会自动退出switch。对于几个不同case同样处理的情况，可以case后面连续几个condition，用逗号隔开。&lt;br&gt;for循环和Java也基本一样，不过也是不需要括号。for循环中，..&amp;lt;的用法比较方便。下划线符号_（替代循环中的变量）能够忽略具体的值，并且不提供循环遍历时对值的访问。for-in则有点类似与Java中for each循环。&lt;br&gt;Swift 2.2中trycatch和do while和java差异很大&lt;/p&gt;
&lt;p&gt;3.2函数和闭包&lt;br&gt;Swift函数的定义和Java很不一样，Swift函数的定义形如 func foo(arg: Type) -&amp;gt;Return Type:&lt;br&gt;Swift中函数是一等公民，可以作为返回值和参数；Swift支持闭包，Java8才支持lambda闭包。&lt;br&gt;Swift支持元组，Swift函数可以通过返回元组支持多个返回值。&lt;br&gt;Swift函数可以嵌套，即一个函数内部还可以定义函数，Java不支持。&lt;br&gt;Swift函数可以接收不定参数，跟Java基本类似&lt;br&gt;Swift函数参数可以带默认值，和Python类似，Java函数不可以带有默认值。&lt;br&gt;常用的函数式编程方法map,reduce, flatMap,filter,sort，相对于理解抽象的函数式编程概念，我觉得开始时先用好这些函数更重要。&lt;/p&gt;
&lt;p&gt;3.3struct vs. class&lt;br&gt;struct是值类，class是引用类型，Java语言没有struct，但c/c++/c#语言都有。&lt;br&gt;Swift开发推荐使用struct，而不是class。Swift语言实现包括几百个struct，只有几个class。&lt;br&gt;Swift类构造方法是init()，析构方法是deinit()，类方法调用跟Java基本一样。&lt;br&gt;self相当于Java中的this，传入生命周期不一致的闭包时需要声明为weak。&lt;/p&gt;
&lt;p&gt;3.4 Enum枚举&lt;br&gt;Android开发谷歌官方不建议使用Enum，影响性能。&lt;br&gt;Swift的Enum和Java类似，本质是一个类，里面可以包含函数。&lt;br&gt;SwiftEnum语法更简单。&lt;br&gt;SwiftEnum支持扩展extension。&lt;/p&gt;
&lt;p&gt;3.5 Interface vs. Protocol&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java Interface &lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Swift Protocol&lt;/strong&gt;&lt;br&gt;•        可以继承&lt;br&gt;•        Interface不能带有具体实现的方法，Java8以后才可以&lt;br&gt;•        implements&lt;/p&gt;
&lt;p&gt;•        可以继承&lt;br&gt;•        protocol可以带有具体实现的方法&lt;br&gt;•        extension更强大&lt;/p&gt;
&lt;p&gt;Extension扩展就是向一个已有的类、结构体或枚举类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（categories）类似。&lt;br&gt;Swift 中的扩展可以：&lt;br&gt;l  添加计算型属性和计算静态属性&lt;br&gt;l  定义实例方法和类型方法&lt;br&gt;l  提供新的构造器&lt;br&gt;l  定义下标&lt;br&gt;l  定义和使用新的嵌套类型&lt;br&gt;l  使一个已有类型符合某个接口&lt;br&gt;需要注意的是扩展方法的作用域问题，这里不展开讨论。&lt;br&gt;3.6 MultiThread多线程&lt;br&gt;&lt;strong&gt;Java Android&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Swift iOS&lt;/strong&gt;&lt;br&gt;•        Thread,Runnable&lt;br&gt;•        Java 5  Concurrency包&lt;br&gt;•        Android多线程扩展&lt;br&gt;•        AsyncTask,Looper,HandleThread,IntentService…&lt;br&gt;•        NSThread&lt;br&gt;•        GCD&lt;br&gt;•        NSOperation，NSOperationQueue&lt;/p&gt;
&lt;p&gt;iOS的多线程相对Java来说比较简单，GCD一天时间基本就能够弄明白。Java的Concurrency包就比较复杂了。&lt;/p&gt;
&lt;p&gt;##4、Android，iOS UI开发比较&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java Android&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Swift iOS&lt;/strong&gt;&lt;br&gt;•        Xml  layout布局&lt;br&gt;•        直接写xml代码，可视化辅助开发&lt;br&gt;•        Android可以用Java添加和实现view&lt;br&gt;•        Intent页面跳转&lt;br&gt;•        Java自定义view,可以在Activity和layout中使用，可视化支持不够好&lt;/p&gt;
&lt;p&gt;•        Xib &amp;amp;  StoryBoard&lt;br&gt;•        AutoLayout和SizeClass，IB自动生成，代码合并困难；&lt;br&gt;•        很多团队只好用代码实现UI界面&lt;br&gt;•        Segue连线跳转&lt;br&gt;•        自定义View可以使用IBDesignable  &amp;amp;  runtime attributes&lt;/p&gt;
&lt;p&gt;iOS开发苹果官方建议使用Storyboard开发UI，好处是比较直观，通过看界面可以更好的理解和维护App。现在Xcode7版本对AutoLayout和SizeClasses的支持越来越好，多分辨率适配变得简单，建议大家放弃使用frame代码写界面的传统做法。&lt;br&gt;当然，Storyboard也有下面的弊端：&lt;br&gt;界面主要依靠IB生成，Xib代码难以维护，Xcode打开Storyboard或Xib就会对文件产生修改，即使我们没有做实际的修改，git也会显示文件修改了。&lt;br&gt;多人协助，同时修改导致冲突，合并困难。&lt;br&gt;Storyboard中包含页面多了后会占用了太多内存，导致Xcode卡顿和崩溃。&lt;br&gt;错误定位困难，错误提示不清晰，新手难以定位错误。例如不小心删掉了IBOutlet会很难定位。&lt;/p&gt;
&lt;p&gt;Storyboard UI 开发实践&lt;br&gt;按照业务模块分成多个Storyboard，每人负责的模块避免交叉。&lt;br&gt;每个storyboard不要超过10个页面，可以通过Refactor  Storyboard功能重新划分。&lt;br&gt;用Container在一个storyboard复用UI模块，用xib在多个storyboard复用UI模块。&lt;br&gt;复杂的输入表单，建议用SwiftyForm框架写代码。&lt;/p&gt;
&lt;p&gt;##5、Android vs Swift iOS框架比较&lt;br&gt;Swift框架现在已经很多了，Swift也可以使用OC开源框架，但不推荐使用。我们主要对比介绍项目常用的网络请求框架，JSON解析和图片缓存框架&lt;br&gt;网络请求框架&lt;br&gt;&lt;strong&gt;Java Android&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Swift iOS&lt;/strong&gt;&lt;br&gt;•        Retrofit&lt;br&gt;•        OKHTTP&lt;br&gt;•        Volley&lt;br&gt;•&lt;br&gt;•        Retrofit  + RxAndroid&lt;/p&gt;
&lt;p&gt;•        Moya&lt;br&gt;•        Alamofire&lt;br&gt;•        AFNetworking&lt;br&gt;•&lt;br&gt;•        Moya +  RxSwift&lt;/p&gt;
&lt;p&gt;在Android开发现在一般使用OKHTTP，Retrofit和Volley等网络框架进行开发，iOS开发oc时代使用AFNetworking库开发，swift开发推荐使用Alamofire和Moya库。&lt;br&gt;Moya 对Alamofire网络请求库进行了封装，开发不需要写网络模型，管理等。使代码更加简洁。Moya可以代替自己编写的网络抽象层APIManager。Moya提供了一些很好的特性：&lt;br&gt;编译期检查API接口调用的正确性&lt;br&gt;通过enum枚举类型清晰的定义不同API的接口&lt;br&gt;把接口测试stub作为一等公民，让单元测试变得很简单。&lt;br&gt;支持ReactiveX扩展，方便和RxSwift集成。&lt;/p&gt;
&lt;p&gt;目前App基本都是使用JSON作为报文协议，Android开发我们一般使用Gson进行解析，在Swift开发中，对比了ObjectMapper，Argo+Curry，SwiftyJson后，我们决定使用ObjectMapper作为JSON解析框架。ObjectMapper支持的特性如下：&lt;br&gt;支持把对象转换成JSON，把JSON转换成类对象&lt;br&gt;支持嵌套的对象（单一对象，对象列表集合和字典）&lt;br&gt;支持自定义的转换函数&lt;br&gt;支持结构体struct&lt;br&gt;支持Realm和Alamofire集成，AlamofireObjectMapper&lt;br&gt;使用例子：&lt;br&gt;let user = Mapper&lt;user&gt;().map(JSONString)&lt;br&gt;    let JSONString = Mapper().toJSONString(user, prettyPrint: true)&lt;br&gt;Realm是iOS开发比较流行的针对移动端设计的数据库，代替sqlite，也有Android版本&lt;br&gt;图片缓存框架，Android开发常用Glide和Fresco，OC开发一般用SDWebImage，Swift开发推荐用HanekeSwift。&lt;/user&gt;&lt;/p&gt;
&lt;p&gt;##6、开发工具比较&lt;br&gt;Android目前主流的开发工具是Android Studio，2014年以前是Eclipse ADT。&lt;br&gt;iOS开发一直使用Xcode。对于Java/Android开发人员来说，Xcode上手较难，特别是Interface Builder，Xib和视图代码直接通过连线来生成事件方法，比较挑战开发习惯，并且出现问题定位困难。而Android开发者习惯手写xml界面代码。&lt;br&gt;与Android Studio相比，Xcode速度快，但不够稳定，一天崩溃几次很正常。&lt;br&gt;模拟器方面，Android的Emulator是虚拟机，启动和安装速度比较慢，iOS是Simulator，速度快，但有些功能不能模拟。都推荐使用真机进行开发。&lt;/p&gt;
&lt;p&gt;包管理器&amp;amp;构建工具对比&lt;br&gt;Android开发早期用Ant做一些任务处理，后面有些团队借鉴Java EE项目的做法用Maven，AndroidStudio出现后谷歌推荐用Gradle。Android的构建工具比iOS功能要强大很多。&lt;br&gt;iOS开发早期用CocoaPods，现在推荐用Carthage，未来Apple官方推出Swift3.0后会推广官方的Swift Package Manager。&lt;br&gt;最后介绍下Xcode包管理器Alcatraz，主要提供Xcode插件，模板和色彩模式，相比Android Studio，目前插件还很比较少。&lt;/p&gt;
</content>
    
    <summary type="html">
    
       从JavaAndroid到Swift iOS开发：语言与框架对比 
    
    </summary>
    
      <category term="Android" scheme="http://offbye.com/categories/Android/"/>
    
      <category term="Swift" scheme="http://offbye.com/categories/Android/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发常用开源框架推荐</title>
    <link href="http://offbye.com/2016/04/26/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%8E%A8%E8%8D%90/"/>
    <id>http://offbye.com/2016/04/26/Android开发常用开源框架推荐/</id>
    <published>2016-04-26T06:49:00.000Z</published>
    <updated>2016-05-12T16:40:00.000Z</updated>
    
    <content type="html">&lt;p&gt;目前我们在Android开发中，不可避免地要用到大量的开源项目，本文对常用的开源项目进行一些推荐。&lt;/p&gt;
&lt;p&gt;首先是如何选择开源项目？建议优先选择github上比较活跃的开源项目，尽量避免从网页上零散的拷贝代码。选择开源项目的原则有下面这些：&lt;br&gt;´ Stars, Issues, Pull Requests&lt;br&gt;´ 文档和Demo，典型用户&lt;br&gt;´ 弄清楚原理&lt;br&gt;´ 结合实际业务场景&lt;/p&gt;
&lt;p&gt;推荐Android开源项目汇总，基本上常见UI效果都能找到&lt;br&gt;&lt;a href=&quot;https://github.com/Trinea/android-open-project&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Trinea/android-open-project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我把常用的框架分为下面几类，分别推荐&lt;br&gt;UI框架和自定义控件&lt;br&gt;网络请求框架&lt;br&gt;图片缓存框架&lt;br&gt;数据存储框架&lt;br&gt;事件总线框架&lt;br&gt;插件化和热部署&lt;/p&gt;
&lt;p&gt;##1、UI框架和自定义控件&lt;br&gt;´ View注入框架&lt;br&gt;´ Butter Knife专注于Android 系统View 的注入框架，结合Android Studio插件使用&lt;br&gt;´ 下拉刷新和加载更多&lt;br&gt;´ Android-PullToRefresh,android-Ultra-Pull-to-Refresh,Android-PullToRefreshRecyclerView&lt;br&gt;´ 侧边栏菜单&lt;br&gt;´ 推荐官方Design支持库自带的&lt;br&gt;´ SlidingMenu，通过拖动屏幕边缘滑出菜单，支持屏幕左右划出，支持菜单 Zoom、Scale、Slide Up 三种动画样式出现&lt;br&gt;´ base-adapter-helper&lt;br&gt;´ 对传统的BaseAdapter ViewHolder 模式的一个封装，主要功能就是简化书写 AbsListView 的 Adapter 的代码，如 ListView，GridView&lt;br&gt;MPAndroidChart图表库&lt;/p&gt;
&lt;p&gt;##2、网络请求框架&lt;br&gt;目前推荐使用Volley + OKHTTP，&lt;br&gt;参考我们自己的脚手架项目，新安卓项目要求使用。&lt;/p&gt;
&lt;p&gt;##3、图片缓存框架&lt;br&gt;推荐使用谷歌官方建议的Glide，备选Facebook的Freso&lt;/p&gt;
&lt;p&gt;##4、数据存储框架&lt;br&gt;无特殊需求推荐使用DBFlow ORM框架。&lt;/p&gt;
&lt;p&gt;##5、事件总线框架&lt;br&gt;推荐使用EventBus。&lt;br&gt;手机App项目根据需求决定是否用EventBus；安卓平板项目，主要基于Fragment实现UI，需要使用EventBus。&lt;/p&gt;
&lt;p&gt;##6、插件化和热部署&lt;br&gt;这块我们只进行了一些实验，没有实际部署。&lt;br&gt;插件化推荐DroidPlugin&lt;br&gt;热部署推荐androidFix&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Android开发常用开源框架推荐 
    
    </summary>
    
      <category term="android开发" scheme="http://offbye.com/categories/android%E5%BC%80%E5%8F%91/"/>
    
      <category term="开源框架" scheme="http://offbye.com/categories/android%E5%BC%80%E5%8F%91/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="开源项目" scheme="http://offbye.com/categories/android%E5%BC%80%E5%8F%91/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift Modules for React Native</title>
    <link href="http://offbye.com/2016/04/22/Swift%20Modules%20for%20React%20Native/"/>
    <id>http://offbye.com/2016/04/22/Swift Modules for React Native/</id>
    <published>2016-04-22T10:20:00.000Z</published>
    <updated>2016-05-12T16:40:01.000Z</updated>
    
    <content type="html">&lt;p&gt;React Native is an Objective-C application framework that bridges JavaScript applications running in the JSCore JavaScript engine to iOS and Android native APIs.&lt;br&gt;In theory, you write your application logic in JSX and ES6/7 and transpile it to JavaScript, and the application framework loads all that as a bundle.&lt;br&gt;In practice, you will want to expose your own custom native code to your JavaScript application. You may want to provide access to 3rd party library APIs or iOS framework features that aren’t exposed (yet) by React Native.&lt;br&gt;React Native is written in Objective-C, but we can write modules in Swift and expose them to our applications. The documentation on the React Native site briefly talks about “&lt;a href=&quot;https://facebook.github.io/react-native/docs/native-modules-ios.html#exporting-swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Exporting Swift&lt;/a&gt;,” but is thin on the details of doing much of anything in Swift. In this article, we’ll do a deeper dive into interfacing Swift to JavaScript.&lt;br&gt;It is assumed you already have React Native and its prerequisites installed on your system. You can find the code used in this article in this GitHub repository:&lt;a href=&quot;https://github.com/ModusCreateOrg/swift-modules-for-react-native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ModusCreateOrg/swift-modules-for-react-native&lt;/a&gt;.&lt;br&gt;Create a React Native project and open it in Xcode:&lt;br&gt;    $ react-native init SwiftBridge&amp;amp;&amp;amp; cd SwiftBridge$ ls&lt;br&gt;    android/         index.ios.js     node_modules/index.android.js ios/package.json&lt;br&gt;    $ ls iosSwiftBridge/SwiftBridge.xcodeproj/SwiftBridgeTests/$ open ios/SwiftBridge.xcodeproj&lt;br&gt;Click the run button in Xcode and see that the project builds and runs.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN01.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN01.png&quot; alt=&quot;SMRN01&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN02.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN02.png&quot; alt=&quot;SMRN02&quot;&gt;&lt;/a&gt;&lt;br&gt;At this point, we know that if the application fails to compile or run, it is something we’ve done to the project at fault.&lt;br&gt;We’ll start by implementing &lt;a href=&quot;https://facebook.github.io/react-native/docs/native-modules-ios.html#exporting-swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;the CalendarManager sample code from the React Native docs&lt;/a&gt; and see that it works.&lt;br&gt;First, we need to add our Swift source file. Right click on SwiftBridge and select “New File…”:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN03.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN03.png&quot; alt=&quot;SMRN03&quot;&gt;&lt;/a&gt;&lt;br&gt;Choose iOS and Swift File from the “Choose template” dialog:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN04.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN04.png&quot; alt=&quot;SMRN04&quot;&gt;&lt;/a&gt;&lt;br&gt;Choose a filename for the file:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN05.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN05.png&quot; alt=&quot;SMRN05&quot;&gt;&lt;/a&gt;&lt;br&gt;You will be asked if you would like to configure an Objective-C bridging header. We will need this, so click on the Create button:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN06.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN06.png&quot; alt=&quot;SMRN06&quot;&gt;&lt;/a&gt;&lt;br&gt;At this point, Xcode has created two files in the project:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN07.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN07.png&quot; alt=&quot;SMRN07&quot;&gt;&lt;/a&gt;&lt;br&gt;We copy the CalendarManager.swift example code from the React Native docs page and paste it into our CalendarManager.swift file:&lt;br&gt;    ////  CalendarManager.swift//  SwiftBridge////  Created by Michael Schwartz on 12/11/15.//  Copyright © 2015 Facebook. All rights reserved.//importFoundation// CalendarManager.swift@objc(CalendarManager)classCalendarManager:NSObject{@objc func addEvent(name:String, location:String, date:NSNumber)-&amp;gt;Void{// Date is ready to use!}}&lt;br&gt;Unfortunately, we have to provide an Objective-C file that exposes our Swift to the React Native Objective-C framework. Create the file “CalendarManageBridge.m” by selecting “New File” as before and choose Objective-C File this time:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN08.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN08.png&quot; alt=&quot;SMRN08&quot;&gt;&lt;/a&gt;&lt;br&gt;This time you will be presented with a “Choose options for your new file” dialog:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN09.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN09.png&quot; alt=&quot;SMRN09&quot;&gt;&lt;/a&gt;&lt;br&gt;Enter “CalendarManagerBridge” in the File text field and click the Next button. Click the Create button on the next dialog:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN10.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN10.png&quot; alt=&quot;SMRN10&quot;&gt;&lt;/a&gt;&lt;br&gt;The file is added to your project.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN11.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN11.png&quot; alt=&quot;SMRN11&quot;&gt;&lt;/a&gt;&lt;br&gt;Copy and paste the code from the React Native docs page to this file:&lt;br&gt;    ////  CalendarManagerBridge.m//  SwiftBridge////  Created by Michael Schwartz on 12/11/15.//  Copyright © 2015 Facebook. All rights reserved.//#import // CalendarManagerBridge.m#import “RCTBridgeModule.h”@interface RCT_EXTERN_MODULE(CalendarManager,NSObject)RCT_EXTERN_METHOD(addEvent:(NSString&lt;em&gt;)name location:(NSString&lt;/em&gt;)location date:(NSNumber*)date)@end&lt;br&gt;Finally, we edit the SwiftBridge-Bridging-Header.h file and copy the two lines from the React Native docs page there:&lt;br&gt;    ////  Use this file to import your target’s public headers that you would like to expose to Swift.//// CalendarManager-Bridging-Header.h#import “RCTBridgeModule.h”&lt;br&gt;Click on the run button in Xcode again and the project should run. If not, you did something wrong in the above steps.&lt;br&gt;In theory, we now have our Swift CalendarManager class exposed to JavaScript. It should appear to JavaScript as React.NativeModules.CalendarManager. Use the editor of your choice to add the following line to index.ios.js, just after the line that required react-native:&lt;br&gt;    varReact=require(‘react-native’);// after this lineconsole.dir(React.NativeModules.CalendarManager);// ← add this line&lt;br&gt;When we run the project from Xcode with this line, we will get a red screen error:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN12.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN12.png&quot; alt=&quot;SMRN12&quot;&gt;&lt;/a&gt;&lt;br&gt;It seems console.dir() is only present if we’re debugging via Chrome. Click the Dismiss (ESC) link on the red screen, then from the Simulator’s Hardware menu, choose Shake Gesture and choose “Debug in Chrome” from the action sheet that appears in the emulator window:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN13.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN13.png&quot; alt=&quot;SMRN13&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN14.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN14.png&quot; alt=&quot;SMRN14&quot;&gt;&lt;/a&gt;&lt;br&gt;You should see a new window or tab in Chrome that looks something like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN15.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN15.png&quot; alt=&quot;SMRN15&quot;&gt;&lt;/a&gt;&lt;br&gt;After hitting Command-Shift-J as the page suggests, you should see something like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN16.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN16.png&quot; alt=&quot;SMRN16&quot;&gt;&lt;/a&gt;&lt;br&gt;Note that the console.dir() did work and you can expand the Object to see that our React.NativeModule.CalendarManager object is exposed to JavaScript and it contains the addEvent() method as we expect.&lt;br&gt;Let’s implement some code in the addEvent() method to see that we can call it from JavaScript and access the arguments passed to Swift. Edit CalendarManager.swift so it looks like this:&lt;br&gt;    ////  CalendarManager.swift//  SwiftBridge////  Created by Michael Schwartz on 12/11/15.//  Copyright © 2015 Facebook. All rights reserved.//importFoundation// CalendarManager.swift@objc(CalendarManager)classCalendarManager:NSObject{@objc func addEvent(name:String, location:String, date:NSNumber)-&amp;gt;Void{NSLog(“%@ %@ %S”, name, location, date);}}&lt;br&gt;All that’s really changed is the NSLog() call to dump the passed variables. Let’s also add a call to the addEvent() method to index.ios.js, just after the console.dir():&lt;br&gt;    React.NativeModules.CalendarManager.addEvent(‘One’,‘Two’,3);&lt;br&gt;When we run this, and the application crashes. There is an error reported in both Chrome Dev Tools and Xcode and in the simulator.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN17.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN17.png&quot; alt=&quot;SMRN17&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN18.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN18.png&quot; alt=&quot;SMRN18&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN19.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN19.png&quot; alt=&quot;SMRN19&quot;&gt;&lt;/a&gt;&lt;br&gt;Note that the NSLog() did work, but the React Native framework displayed the red screen.&lt;br&gt;The fix for this is to add “nonnull” to the CalendarManagerBridge.m file:&lt;br&gt;    RCT_EXTERN_METHOD(addEvent:(NSString&lt;em&gt;)name location:(NSString&lt;/em&gt;)location date:(nonnull NSNumber*)date)&lt;br&gt;With this change, the app works without any errors. We can also see in the Xcode console the NSLog() output:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN20.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN20.png&quot; alt=&quot;SMRN20&quot;&gt;&lt;/a&gt;&lt;br&gt;(Note: I created a GitHub issue about this problem with the React Native documentation page and it has been fixed).&lt;br&gt;We have verified we can access the arguments passed to our Swift method from JavaScript.&lt;br&gt;We cannot simply return values to JavaScript because React Native’s JavaScript/Native bridge is asynchronous. That is, you have to implement your Swift method with a callback parameter and call it with a callback function from JavaScript, or you may implement events.&lt;br&gt;Let’s examine the callback mechanism first. Change the RCT_EXTERN_METHOD line in CalendarManagerBridge.m to read:&lt;br&gt;    RCT_EXTERN_METHOD(addEvent:(NSString&lt;em&gt;)name location:(NSString&lt;/em&gt;)location date:(nonnull NSNumber*)date callback:(RCTResponseSenderBlock)callback);&lt;br&gt;This adds a 4th parameter to the method, a callback function. In CalendarManager.swift, we need to alter the the addEvent() method:&lt;br&gt;    @objc func addEvent(name:String, location:String, date:NSNumber, callback:(NSObject)-&amp;gt;())-&amp;gt;Void{// Date is ready to use!NSLog(“%@ %@ %@”, name, location, date) callback([[“name”: name,”location”: location,”date”: date&lt;br&gt;     ]])}&lt;br&gt;What this version of addEvent() does is call the callback() method with a JavaScript Object that has the argument names/values as key/value pairs. In Swift, we create an NSObject with the [ key: value ] syntax. The argument to the callback from Swift is an array of argument values. In this case, we have just the one Object.&lt;br&gt;We need to modify the JavaScript code in index.ios.js to pass a callback. It should look like this:&lt;br&gt;    React.NativeModules.CalendarManager.addEvent(“One”,”Two”,3,function(o){    console.log(‘InCallback’);    console.dir(o);});&lt;br&gt;When we run this version of the code in the simulator, this is displayed in the JavaScript debugger console:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN21.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN21.png&quot; alt=&quot;SMRN21&quot;&gt;&lt;/a&gt;&lt;br&gt;In order to use events, we need to modify the ‘CalendarManager-Bridging-Header.h’ file to import additional headers from React Native. The file should read:&lt;br&gt;    ////  Use this file to import your target’s public headers that you would like to expose to Swift.//// CalendarManager-Bridging-Header.h#import “RCTBridge.h”#import “RCTBridgeModule.h”#import “RCTEventDispatcher.h”&lt;br&gt;An RCTBridge instance contains an eventDispatcher that we can use to send events to JavaScript from Swift. In order to get this instance, we can have one synthesized for us in our CalendarManager class. We can also verify that it is synthesized by using NSLog() to dump its value.&lt;br&gt;Modify the class’ code in CalendarManager.swift so it looks like this:&lt;br&gt;    classCalendarManager:NSObject{var bridge:RCTBridge!// this is synthesized@objc func addEvent(name:String, location:String, date:NSNumber, callback:(NSObject)-&amp;gt;())-&amp;gt;Void{// Date is ready to use!NSLog(“Bridge: %@”,self.bridge);NSLog(“%@ %@ %@”, name, location, date)    callback([[“name”: name,”location”: location,”date”: date&lt;br&gt;          ]])}}&lt;br&gt;There is the bridge member that will be synthesized and in the addEvent() method there is a call to NSLog() to print the value of the bridge. The value printed should be some hex number that’s the address of the bridge instance.&lt;br&gt;When we run the code, we can see that the bridge member is synthesized:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN22.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN22.png&quot; alt=&quot;SMRN22&quot;&gt;&lt;/a&gt;&lt;br&gt;Note that the code uses NSLog() instead of print(). NSLog is synchronized and works better with threading. It also prints a timestamp and prints to the device console when running on device.&lt;br&gt;Ultimately debug logging should be wrapped by some other means so the printing can be disabled or directed as you want.&lt;br&gt;Modify the CalenderManager class one more time so it looks like this:&lt;br&gt;    classCalendarManager:NSObject{var bridge:RCTBridge!// this is synthesized@objc func addEvent(name:String, location:String, date:NSNumber, callback:(NSObject)-&amp;gt;())-&amp;gt;Void{// Date is ready to use!NSLog(“Bridge: %@”,self.bridge);NSLog(“%@ %@ %@”, name, location, date)let ret =[“name”: name,”location”: location,”date”: date&lt;br&gt;          ]    callback([ret])self.bridge.eventDispatcher.sendAppEventWithName(“EventReminder”, body: ret)}}&lt;br&gt;The sendAppEventWithName() method takes an event name and an arbitrary object that is sent to the JavaScript event handler. In the code above, we’re assigning the NSObject with arguments as key/value pairs to a variable and using it to pass to both the callback() and the event argument.&lt;br&gt;Modify the JavaScript code near the top of index.ios.js so it reads:&lt;br&gt;    varReact=require(‘react-native’)console.dir(React.NativeModules.CalendarManager)var subscription =React.NativeAppEventEmitter.addListener(‘EventReminder’,(reminder)=&amp;gt;{        console.log(‘EVENT’)        console.log(‘name: ‘+ reminder.name)        console.log(‘location: ‘+ reminder.location)        console.log(‘date: ‘+ reminder.date)});React.NativeModules.CalendarManager.addEvent(“One”,”Two”,3,function(o){    console.log(‘In Callback’)    console.dir(o)})&lt;br&gt;We’re really just adding the subscription logic before calling addEvent(). When we run this version of the code, we see the expected output in the Chrome console:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN23.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN23.png&quot; alt=&quot;SMRN23&quot;&gt;&lt;/a&gt;&lt;br&gt;Finally, let’s export some constant members from the CalendarManager swift class to JavaScript. Add this code to the CalendarManager class before the closing brace:&lt;br&gt;    @objc func constantsToExport()-&amp;gt;NSObject{return[“x”:1,”y”:2,”z”:”Arbitrary string”]}&lt;br&gt;When we run the project and expand the first Object printed in the Chrome console, we see our constants:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN24.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://moduscreate.com/wp-content/uploads/2016/01/SMRN24.png&quot; alt=&quot;SMRN24&quot;&gt;&lt;/a&gt;&lt;br&gt;In conclusion, we now have patterns to interface Swift native code to our JavaScript in React Native. From here we can implement our application logic in either language, as appropriate.&lt;/p&gt;
&lt;p&gt;From:  &lt;a href=&quot;http://moduscreate.com/swift-modules-for-react-native/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://moduscreate.com/swift-modules-for-react-native/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Swift Modules for React Native 
    
    </summary>
    
      <category term="Swift" scheme="http://offbye.com/categories/Swift/"/>
    
      <category term="react native" scheme="http://offbye.com/categories/Swift/react-native/"/>
    
      <category term="module" scheme="http://offbye.com/categories/Swift/react-native/module/"/>
    
    
  </entry>
  
  <entry>
    <title>Android官方MVP架构示例项目解析</title>
    <link href="http://offbye.com/2016/04/15/Android%E5%AE%98%E6%96%B9MVP%E6%9E%B6%E6%9E%84%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://offbye.com/2016/04/15/Android官方MVP架构示例项目解析/</id>
    <published>2016-04-15T09:56:00.000Z</published>
    <updated>2016-05-12T16:40:01.000Z</updated>
    
    <content type="html">&lt;p&gt;App架构在Android开发者中一直是讨论比较多的一个话题，目前讨论较多的有MVP、MVVM、Clean这三种。google官方对于架构的态度一直是非常开放的，让开发者自主选择组织和架构app的方式，期望能留给开发者更多的灵活性。&lt;br&gt;由于没有一套权威的架构实现，现在很多App项目中在架构方面都有或多或少的问题。第一种常见问题是没有架构，需求中的一个页面对应项目中的一个activity或一个fragment，所有的界面响应代码、业务逻辑代码、数据请求代码等等都集中在其中。第二种常见的问题是架构实现的不断变化，不断在各种架构间摇摆，一直找不到一个适合自己的架构。&lt;br&gt;就在近日，google在官方示例中给出了一系列不同架构的app实现，这对于一直困惑于到底该用何种架构的android开发者来说确实是福音，开发者只要根据自己项目的情况，在不同的实现中选择一种即可，当然google也明确表示了这些示例只是用来做参考，而并不是要为了当做标准，下面先为大家简单介绍下此项目。&lt;/p&gt;
&lt;p&gt;项目介绍&lt;/p&gt;
&lt;p&gt;Google把这个项目命名为：Android架构蓝图。&lt;br&gt;项目地址为：&lt;a href=&quot;&quot;&gt;https://github.com/googlesamples/android-architecture&lt;/a&gt;&lt;br&gt;下面的内容引用自项目说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目目的是通过展示各种架构app的不同方式来帮助开发者解决架构问题。项目中通过不同的架构概念及方式实现了功能相同的app。你可以用示例来当做参考，或是干脆拿来当做创建app项目的基础。项目中，希望大家能把关注点集中到代码结构、整体架构、可测试性、可维护性这四个方面。当然实现app有很多种方式，千万不要把它当做定式。&lt;br&gt;项目中有哪些示例&lt;br&gt;目前已经完成的示例有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;todo-mvp（mvp基础架构示例）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;todo-mvp-loaders（基于mvp基础架构项目，获取数据部分使用了Loaders架构）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;todo-mvp-databinding（基于mvp基础架构项目，使用了数据绑定组件）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;仍在进展中的示例有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;todo-mvp-contentproviders（基于mvp基础架构项目，使用了Content Providers）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;todo-mvp-clean（基于mvp基础架构项目，使用了clean架构的概念）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;todo-mvp-dagger（基于mvp基础架构项目，使用了dagger2进行依赖注入）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何进行选择&lt;br&gt;这个还是需要开发者自己来做决定，每个项目的说明文件中都说明了该实现的特性。app规模、团队状况、维护工作量的大小、平板是否支持、代码简洁程度偏好，这些都会影响你的选择。&lt;br&gt;到了这里，想必大家都很想一探究竟了，到底官方示例是如何实现的呢？还是那句话，源码面前，了无秘密。为了能够更好的理解官方mvp架构实现，下面我们从源码的角度来分析todo-mvp（mvp基础架构示例）的实现。我们先从项目的整体组织方式开始，再看项目究竟使用了哪些组件，最后当然是最重要的具体mvp的实现方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码分析&lt;/p&gt;
&lt;p&gt;项目代码组织方式&lt;br&gt;项目含一个app src目录，4个测试目录，分别是androidTest（UI层测试）、androidTestMock（UI层测试mock数据支持）、test（业务层单元测试）、mock（业务层单元测试mock数据支持）。src目录的代码组织方式完全是按照功能来组织的，功能内部分为xactivity、xcontract、xfragment、xpresenter四个类文件(x代表业务名称)。&lt;br&gt;平时用到较多的另一种组织方式是按照类型，比如按照activity、adapter、fragment、contract、presenter进行划分，不同的类文件分别放到不同的目录中，笔者觉得两种方式没有什么太大的区别，完全看个人喜好了。&lt;br&gt;组件使用&lt;br&gt;由于项目是基于gradle进行编译的，所以我们可以从build.gradle文件看到项目依赖的全貌。&lt;br&gt;Guava&lt;br&gt;项目中使用到了Guava库（&lt;a href=&quot;&quot;&gt;https://github.com/google/guava&lt;/a&gt;），该库是Google在基于java的项目中都会引用到得一个库，库中包含大约14k的方法数，是个很大的库，其中包含了集合、缓存、并发、基本注解、字符串处理、io处理等等。项目中使用Guava库主要是处理null这种不安全的情况，因为一般我们在使用有可能为null的对象时，一般会增加一次判断，代码如下：&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZE3CCTbZ3V6HKseG3liaxkWyiaMnMW3bYhOFmzMYsSmiameHppDvngbibW4A/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而如果有Guava的时候，可以通过如下方式&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEYWI2fDhf5SbqouFvDCjKLs83rVINllCeQLDwHXHicNJF656u0HwTTlQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样面对空的时候，就不用再多写很多代码了，确实是方便了很多。但是不建议为了null安全直接引入如此大的一个库，因为我们都知道android apk的65k方法数限制，如果要用的话可以把源码中涉及到得部分直接拿出来用。当然Guava中还有很多重要的功能，其他功能读者可以自行研究，关于Guava就先到这里了。&lt;br&gt;测试相关组件&lt;br&gt;示例项目在可测试方面做的非常好，由于对视图逻辑(view层)和业务逻辑(presenter层)进行了拆分，所以我们就可以对UI、业务代码分别进行测试。为了进行UI测试引入了Espresso，为了对业务层进行单元测试引入了junit，为了生成测试mock对象引入了mockito，为了支撑mockito又引入了dexmaker，hamcrest的引入使得测试代码的匹配更接近自然语言，可读性更高，更加灵活。&lt;br&gt;项目MVP实现方式&lt;br&gt;这节我们就具体来看官方示例到底是如何实现mvp的。这里我们先看下总体的轮廓，关于项目中业务代码我们仅列出了任务详情页（taskDetail）的相关类，其他业务代码类似。&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEoDqstaicIwQnRNFnG7gLibtwXlGOzjQOfV6Pa9Eqpt4jGGUvw6rnqhrQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;基类&lt;br&gt;我们首先来看两个Base接口类，BasePresenter与BaseView，两类分别是所有Presenter与View的基类。&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEq0Dl1iboKkY273ic9S5hmy6Mr9HS7BIgsdLm0sKErickoL4mkUrPbTpeA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BasePresenter中含有方法start(),该方法的作用是presenter开始获取数据并调用view中方法改变界面显示，其调用时机是在Fragment类的onResume方法中。&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEQzqEUSJYctsh55iakr0IH4tNVCicEzupCvicajj1qglw3GEq2N2eDvXnA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BaseView中含方法setPresenter，该方法作用是在将presenter实例传入view中，其调用时机是presenter实现类的构造函数中。&lt;br&gt;契约类&lt;br&gt;与笔者之前见到的所有mvp实现都不同，官方的实现中加入了契约类来统一管理view与presenter的所有的接口，这种方式使得view与presenter中有哪些功能，一目了然，维护起来也方便，实例如下&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEcN2BicU7pQicgpjpAbWbsGuRTHdfQQBD5icyw5aNcwNKFWoyvOrLjiaJhg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;activity在mvp中的作用&lt;br&gt;activity在项目中是一个全局的控制者，负责创建view以及presenter实例，并将二者联系起来，下面是activity中创建view及presenter的代码&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEuJu3LyP0t1z7jHk73167kTiblps610icIES1xcEQ4RfpPibRUcvhPIGPw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以从上面看到整个创建过程，而且要注意的是创建后的fragment实例作为presenter的构造函数参数被传入，这样就可以在presenter中调用view中的方法了。&lt;br&gt;mvp的实现与组织&lt;br&gt;实例中将fragment作为view层的实现类，为什么是fragment呢？有两个原因，第一个原因是我们把activity作为一个全局控制类来创建对象，把fragment作为view，这样两者就能各司其职。第二个原因是因为fragment比较灵活，能够方便的处理界面适配的问题。我们先看view的实现，我们只挑一部分重要的方法来看&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZEPiaJulqH9SBzQJlTPJFZLSULxrfh6AUmZwossvQD33LfpPlQZEb9fWA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面可以看到setPresenter方法，该方法继承于父类，通过该方法，view获得了presenter得实例，从而可以调用presenter代码来处理业务逻辑。我们看到在onResume中还调用了presenter得start方法，下面我们再看presenter的实现&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/ibnDKD3ktAoY14s6EJ9BcGia4GjB7HuMZE47Wu7nAjnhzVQENMmv0tCOB8Lfq6N5Im1NS2jzEmZRFqNSypTJAwtg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;presenter构造函数中调用了view得setPresenter方法将自身实例传入，start方法中处理了数据加载与展示。如果需要界面做对应的变化，直接调用view层的方法即可，这样view层与presenter层就能够很好的被划分。&lt;br&gt;最后还剩下model层实现，项目中model层最大的特点是被赋予了数据获取的职责，与我们平常model层只定义实体对象截然不同，实例中，数据的获取、存储、数据状态变化都是model层的任务，presenter会根据需要调用该层的数据处理逻辑并在需要时将回调传入。这样model、presenter、view都只处理各自的任务，此种实现确实是单一职责最好的诠释。&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;到这里我们就基本分析完了，我们再来整体看下官方的实现方式有哪些特性。&lt;br&gt;首先是复杂度，我们可以从上面的分析看出整体的复杂度还是较低的，易学的；然后是可测试性，由于将UI代码与业务代码进行了拆分，整体的可测试性非常的好，UI层和业务层可以分别进行单元测试；最后是可维护性和可扩展性，由于架构的引入，虽然代码量有了一定的上升，但是由于界限非常清晰，各个类职责都非常明确且单一，后期的扩展，维护都会更加容易。有了这个架构之后，我们再回头看下之前的实现是不是有很多不足，没有关系，那么接下来就是在项目中进行实践的时间了。&lt;/p&gt;
&lt;p&gt;原文&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;amp;mid=404088059&amp;amp;idx=3&amp;amp;sn=78dafacbca09b0d7345344c3eef24aff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;amp;mid=404088059&amp;amp;idx=3&amp;amp;sn=78dafacbca09b0d7345344c3eef24aff&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Android官方MVP架构示例项目解析 
    
    </summary>
    
      <category term="android" scheme="http://offbye.com/categories/android/"/>
    
      <category term="mvp" scheme="http://offbye.com/categories/android/mvp/"/>
    
      <category term="架构" scheme="http://offbye.com/categories/android/mvp/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>使用swift开发Cordova插件</title>
    <link href="http://offbye.com/2016/04/15/%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91Cordova%E6%8F%92%E4%BB%B6/"/>
    <id>http://offbye.com/2016/04/15/使用swift开发Cordova插件/</id>
    <published>2016-04-15T07:55:00.000Z</published>
    <updated>2016-05-12T16:40:01.000Z</updated>
    
    <content type="html">&lt;p&gt;最近研究了用swift开发cordova插件的问题，事实证明用swift开发cordova插件是完全可行的，不要再去折腾烦人的oc代码了！主要参考了一个地理围栏插件 &lt;a href=&quot;https://github.com/cowbell/cordova-plugin-geofence&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/cowbell/cordova-plugin-geofence&lt;/a&gt; ，然后自己根据需求开发了百度地图标注和带扫描效果的二维码扫描iOS cordova插件，官方的那个实在太差了。&lt;br&gt;用swift开发插件主要是在项目的 Bridging-Header.h中加入Cordova和插件本身用到的头文件，然后插件类定义要以&lt;br&gt;@objc(HWPXXXXPlugin) class 开头，其它和oc插件基本一样了。示意代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  BaiduMapMarkPlugin.swift&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  cordova-BaiduMapMarkPlugin&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Created by zxt on 2016/04/08.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import Foundation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import WebKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@available(iOS &lt;span class=&quot;number&quot;&gt;8.0&lt;/span&gt;, *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@objc(HWPBaiduMapMarkPlugin) class BaiduMapMarkPlugin : CDVPlugin &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func initialize(command: CDVInvokedUrlCommand) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;BaiduMapMarkPlugin initialization&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func location(command: CDVInvokedUrlCommand) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;location&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var pointUser = PointUser()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; command.arguments != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; command.arguments.count &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let geoInfo = command.arguments[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] as! String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(geoInfo)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let point = convertStringToDictionary(geoInfo)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(convertStringToDictionary(geoInfo))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.storeName = point![&lt;span class=&quot;string&quot;&gt;&quot;storeName&quot;&lt;/span&gt;]!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.pro = point![&lt;span class=&quot;string&quot;&gt;&quot;pro&quot;&lt;/span&gt;]!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.city = point![&lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;]!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.dist = point![&lt;span class=&quot;string&quot;&gt;&quot;dist&quot;&lt;/span&gt;]!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.address = point![&lt;span class=&quot;string&quot;&gt;&quot;address&quot;&lt;/span&gt;]!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.latitude = Double(point![&lt;span class=&quot;string&quot;&gt;&quot;latitude&quot;&lt;/span&gt;]!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pointUser.longitude = Double(point![&lt;span class=&quot;string&quot;&gt;&quot;longitude&quot;&lt;/span&gt;]!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(pointUser)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let mapVc = BaiduMapViewController()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mapVc.isAnon = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mapVc.pointUser = pointUser&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mapVc.callBackId = command.callbackId&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mapVc.baiduMapMarkPlugin = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.viewController?.presentViewController(mapVc, animated: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,completion: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func convertStringToDictionary(text: String) -&amp;gt; [String:String]? &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; let data = text.dataUsingEncoding(&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; try &lt;span class=&quot;built_in&quot;&gt;NSJSONSerialization&lt;/span&gt;.JSONObjectWithData(data, options: []) as? [String:String]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; catch let error as &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                print(error)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;百度地图标注cordova插件项目地址：&lt;br&gt;&lt;a href=&quot;https://github.com/offbye/cordova-plugin-qianmi-baidumapmark&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/offbye/cordova-plugin-qianmi-baidumapmark&lt;/a&gt; &lt;/p&gt;
</content>
    
    <summary type="html">
    
       使用swift开发Cordova插件 
    
    </summary>
    
      <category term="Swift" scheme="http://offbye.com/categories/Swift/"/>
    
      <category term="cordova" scheme="http://offbye.com/categories/Swift/cordova/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift语言中的@available 和</title>
    <link href="http://offbye.com/2016/04/14/Swift%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84@available%20%E5%92%8C%20#available/"/>
    <id>http://offbye.com/2016/04/14/Swift语言中的@available 和 #available/</id>
    <published>2016-04-14T05:43:00.000Z</published>
    <updated>2016-05-12T16:40:02.000Z</updated>
    
    <content type="html">&lt;p&gt;Swift 2.0 中，引入了可用性的概念。对于函数，类，协议等，可以使用&lt;code&gt;@available&lt;/code&gt;声明这些类型的生命周期依赖于特定的平台和操作系统版本。而&lt;code&gt;#available&lt;/code&gt;用在判断语句中（if, guard, while等），在不同的平台上做不同的逻辑。&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;##@available&lt;/p&gt;
&lt;p&gt;###用法&lt;br&gt;&lt;code&gt;@available&lt;/code&gt;放在函数（方法），类或者协议前面。表明这些类型适用的平台和操作系统。看下面一个例子：&lt;br&gt;    @available(iOS 9, *)&lt;br&gt;    funcmyMethod() {&lt;br&gt;        // do something&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@available(iOS 9, *)&lt;/code&gt;必须包含至少2个特性参数，其中&lt;code&gt;iOS 9&lt;/code&gt;表示必须在 iOS 9 版本以上才可用。如果你部署的平台包括 iOS 8 , 在调用此方法后，编译器会报错。&lt;br&gt;另外一个特性参数：星号（*），表示包含了所有平台，目前有以下几个平台：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iOS&lt;/li&gt;
&lt;li&gt;iOSApplicationExtension&lt;/li&gt;
&lt;li&gt;OSX&lt;/li&gt;
&lt;li&gt;OSXApplicationExtension&lt;/li&gt;
&lt;li&gt;watchOS&lt;/li&gt;
&lt;li&gt;watchOSApplicationExtension&lt;/li&gt;
&lt;li&gt;tvOS&lt;/li&gt;
&lt;li&gt;tvOSApplicationExtension&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来讲，如果没有特殊的情况，都使用&lt;code&gt;*&lt;/code&gt;表示全平台。&lt;br&gt;&lt;code&gt;@available(iOS 9, *)&lt;/code&gt;是一种简写形式。全写形式是&lt;code&gt;@available(iOS, introduced=9.0)&lt;/code&gt;。&lt;code&gt;introduced=9.0&lt;/code&gt;参数表示指定平台(iOS)从 9.0 开始引入该声明。为什么可以采用简写形式呢？当只有&lt;code&gt;introduced&lt;/code&gt;这样一种参数时，就可以简写成以上简写形式。同理：@available(iOS 8.0, OSX 10.10, *) 这样也是可以的。表示同时在多个平台上（iOS 8.0 及其以上；OSX 10.10及其以上）的可用性。&lt;br&gt;另外，&lt;code&gt;@available&lt;/code&gt;还有其他一些参数可以使用，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;deprecated=版本号&lt;/code&gt;：从指定平台某个版本开始过期该声明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obsoleted=版本号&lt;/code&gt;：从指定平台某个版本开始废弃（注意弃用的区别，&lt;code&gt;deprecated&lt;/code&gt;是还可以继续使用，只不过是不推荐了，&lt;code&gt;obsoleted&lt;/code&gt;是调用就会编译错误）该声明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message=信息内容&lt;/code&gt;：给出一些附加信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unavailable&lt;/code&gt;：指定平台上是无效的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;renamed=新名字&lt;/code&gt;：重命名声明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上参数具体可以参考&lt;a href=&quot;http://wiki.jikexueyuan.com/project/swift/chapter3/06_Attributes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###available&lt;br&gt;&lt;code&gt;#available&lt;/code&gt; 用在条件语句代码块中，判断不同的平台下，做不同的逻辑处理，比如：&lt;br&gt;    if#available(iOS 8, *) {&lt;br&gt;    // iOS 8 及其以上系统运行&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;guard #available(iOS 8, *) else {
return//iOS 8 以下系统就直接返回
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###stackoverflow 相关问题整理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/32761511/difference-between-available-and-available-in-swift-2-0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Difference between @available and #available in swift 2.0&lt;/a&gt;: @available 和 #available&lt;br&gt;帖子里面还提到一个问题：&lt;code&gt;@available&lt;/code&gt;是编译期间判断的吗？而&lt;code&gt;#available&lt;/code&gt;是运行时行为吗&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
       Swift语言中的@available 和 #available 
    
    </summary>
    
      <category term="Swift" scheme="http://offbye.com/categories/Swift/"/>
    
      <category term="available" scheme="http://offbye.com/categories/Swift/available/"/>
    
    
  </entry>
  
  <entry>
    <title>Android volley 使用OkHttp3.0</title>
    <link href="http://offbye.com/2016/03/31/Android%20volley%20%E4%BD%BF%E7%94%A8OkHttp3.0/"/>
    <id>http://offbye.com/2016/03/31/Android volley 使用OkHttp3.0/</id>
    <published>2016-03-31T01:31:00.000Z</published>
    <updated>2016-05-12T16:40:02.000Z</updated>
    
    <content type="html">&lt;p&gt;本文仅介绍如何使用OKHttp3.0实现HttpStack，从而接管volley的网络请求。&lt;/p&gt;
&lt;p&gt;##前言：&lt;br&gt;volley —- Google出品的android平台轻量级网络库&lt;br&gt;     　　　  优点：扩展性强，请求队列管理&lt;br&gt;　　　　　基本介绍：&lt;a href=&quot;http://blog.csdn.net/t12x3456/article/details/9221611/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/t12x3456/article/details/9221611/&lt;/a&gt;&lt;br&gt;　　　　　github镜像: &lt;a href=&quot;https://github.com/mcxiaoke/android-volley&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mcxiaoke/android-volley&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;okhttp—-Square出品的java网络库，android4.4以后已作为默认的HTTP连接实现&lt;br&gt;　　　　   优点：支持SPDY，连接池，传输效率的各种优化&lt;br&gt;　　　　　源码：&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/square/okhttp&lt;/a&gt;&lt;br&gt;　　　　   官方wiki：&lt;a href=&quot;https://github.com/square/okhttp/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/square/okhttp/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##正文：&lt;br&gt;OkHttp 3.x相对于2.x，在api以及使用规范上有一些调整，所以在实现HttpStack的时候要做相应的更改，基本用法不变。&lt;br&gt;参考来源：&lt;a href=&quot;http://blog.csdn.net/lonewolf521125/article/details/47256475&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lonewolf521125/article/details/47256475&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面直接上代码，红色部分关注一下即可。&lt;br&gt;&lt;a href=&quot;&amp;quot;复制代码&amp;quot;&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;&gt;&lt;/a&gt;      1 package com.xxx.xxx;  2&lt;br&gt;      3 import com.android.volley.AuthFailureError;  4 import com.android.volley.Request;  5 import com.android.volley.toolbox.HttpStack;  6&lt;br&gt;      7 import org.apache.http.HttpEntity;  8 import org.apache.http.HttpResponse;  9 import org.apache.http.ProtocolVersion; 10 import org.apache.http.StatusLine; 11 import org.apache.http.entity.BasicHttpEntity; 12 import org.apache.http.message.BasicHeader; 13 import org.apache.http.message.BasicHttpResponse; 14 import org.apache.http.message.BasicStatusLine; 15&lt;br&gt;     16 import java.io.IOException; 17 import java.util.Map; 18 import java.util.concurrent.TimeUnit; 19&lt;br&gt;     20 import okhttp3.Call; 21 import okhttp3.Headers; 22 import okhttp3.MediaType; 23 import okhttp3.OkHttpClient; 24 import okhttp3.Protocol; 25 import okhttp3.RequestBody; 26 import okhttp3.Response; 27 import okhttp3.ResponseBody; 28&lt;br&gt;     29 /&lt;strong&gt;&lt;br&gt;     30  &lt;em&gt; The MIT License (MIT) 31  &lt;/em&gt; &lt;p&gt; 32  &lt;em&gt; Copyright (c) 2015 Circle Internet Financial 33  &lt;/em&gt; &lt;/p&gt;&lt;p&gt; 34  &lt;em&gt; Permission is hereby granted, free of charge, to any person obtaining a copy 35  &lt;/em&gt; of this software and associated documentation files (the “Software”), to deal 36  &lt;em&gt; in the Software without restriction, including without limitation the rights 37  &lt;/em&gt; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 38  &lt;em&gt; copies of the Software, and to permit persons to whom the Software is 39  &lt;/em&gt; furnished to do so, subject to the following conditions: 40  &lt;em&gt; &lt;p&gt; 41  &lt;/p&gt;&lt;/em&gt; The above copyright notice and this permission notice shall be included in 42  &lt;em&gt; all copies or substantial portions of the Software. 43  &lt;/em&gt; &lt;/p&gt;&lt;p&gt; 44  &lt;em&gt; THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 45  &lt;/em&gt; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 46  &lt;em&gt; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 47  &lt;/em&gt; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 48  &lt;em&gt; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 49  &lt;/em&gt; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 50  &lt;em&gt; THE SOFTWARE. 51  &lt;/em&gt;/&lt;br&gt;     52&lt;br&gt;     53 /&lt;/p&gt;&lt;/strong&gt;&lt;br&gt;     54  &lt;em&gt; OkHttp backed {@link com.android.volley.toolbox.HttpStack HttpStack} that 55  &lt;/em&gt; does not use okhttp-urlconnection 56  */&lt;br&gt;     57 public class OkHttpStack implements HttpStack { 58&lt;br&gt;     59     private final OkHttpClient mClient; 60&lt;br&gt;     61     public OkHttpStack(OkHttpClient client) { 62         this.mClient = client; 63     } 64&lt;br&gt;     65     @Override 66     public HttpResponse performRequest(Request&amp;lt;?&amp;gt; request, 67             Map&lt;string, string=&quot;&quot;&gt; additionalHeaders) throws IOException, AuthFailureError { 68&lt;br&gt;     69         int timeoutMs = request.getTimeoutMs(); 70         // okhttp 3.0以后的版本构建OkHttpClient使用Builder&lt;br&gt;     71         OkHttpClient.Builder builder = mClient.newBuilder(); 72         builder.connectTimeout(timeoutMs, TimeUnit.MILLISECONDS) 73                 .readTimeout(timeoutMs, TimeUnit.MILLISECONDS) 74                 .writeTimeout(timeoutMs, TimeUnit.MILLISECONDS); 75         OkHttpClient client = builder.build(); 76&lt;br&gt;     77         okhttp3.Request.Builder okHttpRequestBuilder = new okhttp3.Request.Builder(); 78         okHttpRequestBuilder.url(request.getUrl()); 79&lt;br&gt;     80         Map&lt;string, string=&quot;&quot;&gt; headers = request.getHeaders(); 81         for (final String name : headers.keySet()) { 82             okHttpRequestBuilder.addHeader(name, headers.get(name)); 83         } 84         for (final String name : additionalHeaders.keySet()) { 85             // 这里用header方法，如果有重复的name，会覆盖，否则某些请求会被判定为非法&lt;br&gt;     86             okHttpRequestBuilder.header(name, additionalHeaders.get(name)); 87         } 88&lt;br&gt;     89         setConnectionParametersForRequest(okHttpRequestBuilder, request); 90&lt;br&gt;     91         okhttp3.Request okHttpRequest = okHttpRequestBuilder.build(); 92         Call okHttpCall = client.newCall(okHttpRequest); 93         Response okHttpResponse = okHttpCall.execute(); 94&lt;br&gt;     95         StatusLine responseStatus = new BasicStatusLine( 96                 parseProtocol(okHttpResponse.protocol()), okHttpResponse.code(), 97                 okHttpResponse.message()); 98         BasicHttpResponse response = new BasicHttpResponse(responseStatus); 99         response.setEntity(entityFromOkHttpResponse(okHttpResponse));100&lt;br&gt;    101         Headers responseHeaders = okHttpResponse.headers();102         for (int i = 0, len = responseHeaders.size(); i &amp;lt; len; i++) {103             final String name = responseHeaders.name(i), value = responseHeaders.value(i);104             if (name != null) {105                 response.addHeader(new BasicHeader(name, value));106             }107         }108&lt;br&gt;    109         return response;110     }111&lt;br&gt;    112     private static HttpEntity entityFromOkHttpResponse(Response r) throws IOException {113         BasicHttpEntity entity = new BasicHttpEntity();114         ResponseBody body = r.body();115&lt;br&gt;    116         entity.setContent(body.byteStream());117         entity.setContentLength(body.contentLength());118         entity.setContentEncoding(r.header(“Content-Encoding”));119&lt;br&gt;    120         if (body.contentType() != null) {121             entity.setContentType(body.contentType().type());122         }123         return entity;124     }125&lt;br&gt;    126     @SuppressWarnings(“deprecation”)127     private static void setConnectionParametersForRequest(128             okhttp3.Request.Builder builder, Request&amp;lt;?&amp;gt; request) throws IOException,129             AuthFailureError {130         switch (request.getMethod()) {131             case Request.Method.DEPRECATED_GET_OR_POST:132                 // Ensure backwards compatibility. Volley assumes a request with133                 // a null body is a GET.&lt;br&gt;    134                 byte[] postBody = request.getPostBody();135                 if (postBody != null) {136                     builder.post(RequestBody.create(137                             MediaType.parse(request.getPostBodyContentType()), postBody));138                 }139                 break;140             case Request.Method.GET:141                 builder.get();142                 break;143             case Request.Method.DELETE:144                 builder.delete();145                 break;146             case Request.Method.POST:147                 builder.post(createRequestBody(request));148                 break;149             case Request.Method.PUT:150                 builder.put(createRequestBody(request));151                 break;152             case Request.Method.HEAD:153                 builder.head();154                 break;155             case Request.Method.OPTIONS:156                 builder.method(“OPTIONS”, null);157                 break;158             case Request.Method.TRACE:159                 builder.method(“TRACE”, null);160                 break;161             case Request.Method.PATCH:162                 builder.patch(createRequestBody(request));163                 break;164             default:165                 throw new IllegalStateException(“Unknown method type.”);166         }167     }168&lt;br&gt;    169     private static ProtocolVersion parseProtocol(final Protocol p) {170         switch (p) {171             case HTTP_1_0:172                 return new ProtocolVersion(“HTTP”, 1, 0);173             case HTTP_1_1:174                 return new ProtocolVersion(“HTTP”, 1, 1);175             case SPDY_3:176                 return new ProtocolVersion(“SPDY”, 3, 1);177             case HTTP_2:178                 return new ProtocolVersion(“HTTP”, 2, 0);179         }180&lt;br&gt;    181         throw new IllegalAccessError(“Unkwown protocol”);182     }183&lt;br&gt;    184     private static RequestBody createRequestBody(Request r) throws AuthFailureError {185         byte[] body = r.getBody();186         if (body == null) {187             // OkHttp内部默认的的判断逻辑是POST 不能为空，这里做了规避&lt;br&gt;    188             if (r.getMethod() == Request.Method.POST) {189                 body = “”.getBytes();190             }191             else {192                 return null;193             }194         }195&lt;br&gt;    196         return RequestBody.create(MediaType.parse(r.getBodyContentType()), body);197     }198 }&lt;br&gt;&lt;a href=&quot;&amp;quot;复制代码&amp;quot;&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;&gt;&lt;/a&gt; 在volley的调用：&lt;br&gt;    1 OkHttpClient okClient = new OkHttpClient.Builder().build();2&lt;br&gt;    3 RequestQueue queue = Volley.newRequestQueue(context, new OkHttpStack(okClient));&lt;/string,&gt;&lt;/string,&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Android volley 使用OkHttp3.0 
    
    </summary>
    
      <category term="okhttp" scheme="http://offbye.com/categories/okhttp/"/>
    
      <category term="volley" scheme="http://offbye.com/categories/okhttp/volley/"/>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s new in Swift 2.2</title>
    <link href="http://offbye.com/2016/03/28/What's%20new%20in%20Swift%202.2/"/>
    <id>http://offbye.com/2016/03/28/What's new in Swift 2.2/</id>
    <published>2016-03-28T06:12:00.000Z</published>
    <updated>2016-05-12T16:40:02.000Z</updated>
    
    <content type="html">&lt;p&gt;From &lt;a href=&quot;https://www.hackingwithswift.com/swift2-2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.hackingwithswift.com/swift2-2&lt;/a&gt;&lt;br&gt;Swift 2.2 is almost here, and cleans up a numberof quirks, adds some missing features, and deprecates – perhaps controversially – some language features. This article goes over all the major changes, along with several minor ones, and gives you practical code examples so you can get up and running straight away.&lt;br&gt;If you liked this article, you might also want to read:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/swift2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What’s new in Swift 2.0?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/ios9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What’s new in iOS 9?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;My free Swift tutorial series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gum.co/proswift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pre-order Pro Swift for just $20!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Watch my Swift 2.2 video&lt;br&gt;I made a video going over the key new features in Swift 2.2. You can read the original article below, or watch this video for my lightning summary. Feedback? &lt;a href=&quot;http://www.twitter.com/twostraws&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Find me on Twitter @twostraws&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;##++ and – are deprecated&lt;br&gt;Swift 2.2 formally deprecates the &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators, which means they still work but you’ll get a warning when you use them. Deprecation is usually a first step towards removing something entirely, and in this case both of these operators will be removed in Swift 3.0.&lt;br&gt;In their place, you need to use &lt;code&gt;+= 1&lt;/code&gt; and &lt;code&gt;-= 1&lt;/code&gt; instead. These operators have been there all along, and are not going away.&lt;br&gt;You might wonder why two long-standing operators are being removed, particularly when they exist in C, C#, Java, and – critically to its “joke” – C++. There are several answers, not least:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Writing &lt;code&gt;++&lt;/code&gt; rather than &lt;code&gt;+= 1&lt;/code&gt; is hardly a dramatic time saving&lt;/li&gt;
&lt;li&gt;Although it’s easy once you know it, &lt;code&gt;++&lt;/code&gt; doesn’t have an obvious meaning to people learning Swift, whereas &lt;code&gt;+=&lt;/code&gt; at least reads as “add and assign.”&lt;/li&gt;
&lt;li&gt;C-style loops – one of the most common situations where &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; were used – have also been deprecated, which brings me on to my next point…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##Traditional C-style for loops are deprecated&lt;br&gt;Yes, you read that correctly: loops like the below will soon be removed entirely from Swift:&lt;br&gt;    for var i = 1; i &amp;lt;= 10; i += 1 {&lt;br&gt;        print(“(i) green bottles”)&lt;br&gt;    }&lt;br&gt;These are called C-style for loops because they have long been a feature of C-like languages, and conceptually even pre-date C by quite a long way.&lt;br&gt;Although Swift is (just about!) a C-like language, it has a number of newer, smarter alternatives to the traditional for loop. The result: this construct has been deprecated in Swift 2.2 and will be removed “in a future version of Swift.”&lt;br&gt;Note: the current deprecation warning does not say it’s removed in Swift 3.0, although I suspect it will be.&lt;br&gt;To replace these old for loops, use one of the many alternatives. For example, the “green bottles” code above could be rewritten to loop over a range, like this:&lt;br&gt;    for i in 1…10 {&lt;br&gt;        print(“(i) green bottles”)&lt;br&gt;    }&lt;br&gt;Remember, though, that it’s a bad idea to create a range where the start is higher than the end: your code will compile, but it will crash at runtime. So, rather than writing this:&lt;br&gt;    for i in 10…1 {&lt;br&gt;        print(“(i) green bottles”)&lt;br&gt;    }&lt;br&gt;…you should write this instead:&lt;br&gt;    for i in (1…10).reverse() {&lt;br&gt;        print(“(i) green bottles”)&lt;br&gt;    }&lt;br&gt;Another alternative is just to use regular fast enumeration over an array of items, like this:&lt;br&gt;    var array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for number in array {
    print(&amp;quot;\(number) green bottles&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Although if you want to be technically correct (also known as “the best kind of correct”) you would write such a beast like this:&lt;br&gt;    var array = Array(1…10)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for number in array {
    print(&amp;quot;\(number) green bottles&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##Arrays and other slice types now have removeFirst()&lt;br&gt;The &lt;code&gt;removeLast()&lt;/code&gt; method has always been helpful when working with arrays, but until now it’s been missing a counterpart to remove items from the start of an array.&lt;br&gt;Well, Swift 2.2 is here to rescue you with the addition of the &lt;code&gt;removeFirst()&lt;/code&gt; method. This removes the first element in an array, and returns it to you.&lt;br&gt;Looking back to the green bottles code above, you’ll notice two quirks: first, I was using &lt;code&gt;var&lt;/code&gt; rather than &lt;code&gt;let&lt;/code&gt;, and second it was printing the grammatically incorrect message “1 green bottles”.&lt;br&gt;Neither of these are a mistake, because I’m going to use them to demonstrate &lt;code&gt;removeFirst()&lt;/code&gt;:&lt;br&gt;    var array = Array(1…10)&lt;br&gt;    array.removeFirst()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for number in array {
    print(&amp;quot;\(number) green bottles&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Warning: whereas &lt;code&gt;removeLast()&lt;/code&gt; has an optional equivalent, &lt;code&gt;popLast()&lt;/code&gt;, there is no optional equivalent for &lt;code&gt;removeFirst()&lt;/code&gt;. This means if you call it on an empty array, your code will crash.&lt;/p&gt;
&lt;p&gt;##You can now compare tuples (within reason)&lt;br&gt;A tuple is simply a comma-separated list of values, where each value may or may not be named. For example:&lt;br&gt;    let singer = (“Taylor”, “Swift”)&lt;br&gt;    let alien = (“Justin”, “Bieber”)&lt;br&gt;In older versions of Swift, you couldn’t compare two tuples without writing some unwieldy code like this:&lt;br&gt;    func ==  (t1: (T, T), t2: (T, T)) -&amp;gt; Bool {&lt;br&gt;        return t1.0 == t2.0 &amp;amp;&amp;amp; t1.1 == t2.1&lt;br&gt;    }&lt;br&gt;It’s not very user-friendly to require that kind of boilerplate code, and of course it would only work for tuples that have exactly two elements. In Swift 2.2, you no longer need to write that code because tuples can be compared directly:&lt;br&gt;    let singer = (“Taylor”, “Swift”)&lt;br&gt;    let alien = (“Justin”, “Bieber”)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if singer == alien {
    print(&amp;quot;Matching tuples!&amp;quot;)
} else {
    print(&amp;quot;Non-matching tuples!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Swift 2.2’s automatic tuple comparison works with tuples with two elements just like the function we wrote, but it also works with tuples of other sizes – up to arity 6, which means a tuple that contains six elements.&lt;br&gt;(In case you were wondering: “arity” is pronounced like “arrity”, but “tuple” is pronounced any number of ways: “toople”, “tyoople” and “tupple” are all common.)&lt;br&gt;There are two reasons why Swift’s tuple comparisons work only up to arity 6 (rather than arity 6 million). First, each extra comparison requires more code inside the Swift standard library. Second, using tuples that big is probably a code smell – switch to a struct instead.&lt;br&gt;You can see how tuple comparison works by changing our two tuples like this:&lt;br&gt;    let singer = (“Taylor”, 26)&lt;br&gt;    let alien = (“Justin”, “Bieber”)&lt;br&gt;Be prepared for a very long error message from Xcode, but the interesting part comes near the end:&lt;br&gt;    note: overloads for ‘==’ exist with these partially matching parameter lists: ……&lt;br&gt;    ((A, B), (A, B)), ((A, B, C), (A, B, C)), ((A, B, C, D), (A, B, C, D)), ((A, B, C, D, E), (A, B, C, D, E)), ((A, B, C, D, E, F), (A, B, C, D, E, F))&lt;br&gt;As you can see, Swift literally has functions to compare tuples all the way up to &lt;code&gt;(A, B, C, D, E, F)&lt;/code&gt;, which ought to be more than enough.&lt;/p&gt;
&lt;p&gt;##Tuple splat syntax is deprecated&lt;br&gt;Staying with tuples for a moment longer: another feature that has been deprecated is one that has been part of Swift since 2010 (yes, years before it launched). It’s been named “the tuple splat”, and not many people were using it. It’s partly for that reason – although mainly because it introduces all sorts of ambiguities when reading code – that this syntax is being deprecated.&lt;br&gt;In case you were curious – and let’s face it, you probably are – here’s an example of tuple splat syntax in action:&lt;br&gt;    func describePerson(name: String, age: Int) {&lt;br&gt;        print(“(name) is (age) years old”)&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let person = (&amp;quot;Taylor Swift&amp;quot;, age: 26)
describePerson(person)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But remember: don’t grow too fond of your new knowledge, because tuple splats are deprecated in Swift 2.2 and will be removed entirely in a later version.&lt;/p&gt;
&lt;p&gt;##More keywords can be used as argument labels&lt;br&gt;Argument labels are a core feature of Swift, and let us write code like this:&lt;br&gt;    for i in 1.stride(through: 9, by: 2) {&lt;br&gt;        print(i)&lt;br&gt;    }&lt;br&gt;Without the &lt;code&gt;through&lt;/code&gt; or &lt;code&gt;by&lt;/code&gt; labels, this code would lose its self-documenting nature: what do the 9 and 2 do in &lt;code&gt;1.stride(9, 2)&lt;/code&gt;? In this example, Swift also uses the argument labels to distinguish &lt;code&gt;1.stride(through: 9, by: 2)&lt;/code&gt; from &lt;code&gt;1.stride(to: 9, by: 2)&lt;/code&gt;, which produces different results.&lt;br&gt;As of Swift 2.2, you can now use a variety of language keywords as these argument labels. You might wonder why this would be a good thing, but consider this code:&lt;br&gt;    func printGreeting(name: String, repeat repeatCount: Int) {&lt;br&gt;        for _ in 0 ..&amp;lt; repeatCount {&lt;br&gt;            print(name)&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printGreeting(&amp;quot;Taylor&amp;quot;, repeat: 5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That uses &lt;code&gt;repeat&lt;/code&gt; as an argument label, which makes sense because the function will print a string a number of times. Because &lt;code&gt;repeat&lt;/code&gt; is a keyword, this code would not work before Swift 2.2 – you would need to write &lt;code&gt;repeat&lt;/code&gt; instead, which is unpleasant.&lt;br&gt;Note that there are still some keywords that may not be used, specifically &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;inout&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;##var parameters have been deprecated&lt;br&gt;Another deprecation, but again with good reason: &lt;code&gt;var&lt;/code&gt; parameters are deprecated because they offer only marginal usefulness, and are frequently confused with &lt;code&gt;inout&lt;/code&gt;. These things are so sneaky I couldn’t resist adding one to my &lt;a href=&quot;https://www.hackingwithswift.com/test/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift language tests&lt;/a&gt;, although I will probably have removed them by the time you read this!&lt;br&gt;To give you an example, here is the &lt;code&gt;printGreeting()&lt;/code&gt; function modified to use &lt;code&gt;var&lt;/code&gt;:&lt;br&gt;    func printGreeting(var name: String, repeat repeatCount: Int) {&lt;br&gt;        name = name.uppercaseString&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    for _ in 0 ..&amp;lt; repeatCount {
        print(name)
    }
}

printGreeting(&amp;quot;Taylor&amp;quot;, repeat: 5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The differences there are in the first two lines: &lt;code&gt;name&lt;/code&gt; is now &lt;code&gt;var name&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt; gets converted to uppercase so that “TAYLOR” is printed out five times.&lt;br&gt;Without the &lt;code&gt;var&lt;/code&gt; keyword, &lt;code&gt;name&lt;/code&gt; would have been a constant and so the &lt;code&gt;uppercaseString&lt;/code&gt; line would have failed.&lt;br&gt;The difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;inout&lt;/code&gt; is subtle: using &lt;code&gt;var&lt;/code&gt; lets you modify a parameter inside the function, whereas &lt;code&gt;inout&lt;/code&gt;causes your changes to persist even after the function ends.&lt;br&gt;As of Swift 2.2, &lt;code&gt;var&lt;/code&gt; is deprecated, and it’s slated for removal in Swift 3.0. If this is something you were using, just create a variable copy of the parameter inside the method, like this:&lt;br&gt;    func printGreeting(name: String, repeat repeatCount: Int) {&lt;br&gt;        let upperName = name.uppercaseString&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    for _ in 0 ..&amp;lt; repeatCount {
        print(upperName)
    }
}

printGreeting(&amp;quot;Taylor&amp;quot;, repeat: 5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##Renamed debug identifiers: #line, #function, #file&lt;br&gt;Swift 2.1 and earlier used the “screaming snake case” symbols &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, &lt;code&gt;__COLUMN__&lt;/code&gt;, and &lt;code&gt;__FUNCTION__&lt;/code&gt;, which automatically get replaced the compiler by the filename, line number, column number and function name where they appear.&lt;br&gt;In Swift 2.2, those old symbols have been replaced with &lt;code&gt;#file&lt;/code&gt;, &lt;code&gt;#line&lt;/code&gt;, &lt;code&gt;#column&lt;/code&gt; and &lt;code&gt;#function&lt;/code&gt;, which will be familiar to you if you’ve already used &lt;a href=&quot;https://www.hackingwithswift.com/new-syntax-swift-2-availability-checking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swift 2.0’s #available&lt;/a&gt; to check for iOS features. As the official Swift review says, it also introduces “a convention where # means invoke compiler substitution logic here.”&lt;br&gt;Below I’ve modified the &lt;code&gt;printGreeting()&lt;/code&gt; function so you can see both the old and new debug identifiers in action:&lt;br&gt;    func printGreeting(name: String, repeat repeatCount: Int) {&lt;br&gt;        // old - deprecated!&lt;br&gt;        print(“This is on line (&lt;strong&gt;LINE&lt;/strong&gt;) of (&lt;strong&gt;FUNCTION&lt;/strong&gt;)”)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // new - shiny!
    print(&amp;quot;This is on line \(#line) of \(#function)&amp;quot;)

    let upperName = name.uppercaseString

    for _ in 0 ..&amp;lt; repeatCount {
        print(upperName)
    }
}

printGreeting(&amp;quot;Taylor&amp;quot;, repeat: 5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For the sake of completion, I should add that you can also use &lt;code&gt;#dsohandle&lt;/code&gt;, but if you know what dynamic shared object handles are you probably already spotted this change yourself!&lt;/p&gt;
&lt;p&gt;##Stringified selectors are deprecated&lt;br&gt;One unwelcome quirk of Swift before 2.2 was that selectors could be written as strings, like this:&lt;br&gt;    navigationItem.rightBarButtonItem = UIBarButtonItem(title: “Tap!”, style: .Plain, target: self, action: “buttonTaped”)&lt;br&gt;If you look closely, I wrote &lt;code&gt;&amp;quot;buttonTaped&amp;quot;&lt;/code&gt; rather than &lt;code&gt;&amp;quot;buttonTapped&amp;quot;&lt;/code&gt;, but Xcode wasn’t able to notify me of my mistake if either of those methods didn’t exist.&lt;br&gt;This has been resolved as of Swift 2.2: using strings for selectors has been deprecated, and you should now write&lt;code&gt;#selector(buttonTapped)&lt;/code&gt; in that code above. If the &lt;code&gt;buttonTapped()&lt;/code&gt; method doesn’t exist, you’ll get a compile error – another whole class of bugs eliminated at compile time!&lt;/p&gt;
&lt;p&gt;##Compile-time Swift version checking&lt;br&gt;Swift 2.2 adds a new build configuration option that makes it easy to combine code code written in versions of Swift into a single file. This might seem unnecessary, but spare a thought to people who write libraries in Swift: do they target Swift 2.2 and hope everyone is using it, or target Swift 2.0 and hope users can upgrade using Xcode?&lt;br&gt;Using the new build option lets you write two different flavours of Swift, and the correct one will be compiled depending on the version of the Swift compiler.&lt;br&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#if swift(&amp;gt;=2.2)
print(&amp;quot;Running Swift 2.2 or later&amp;quot;)
#else
print(&amp;quot;Running Swift 2.1 or earlier&amp;quot;)
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just like the existing &lt;code&gt;#if os()&lt;/code&gt; build option, this adjusts what code is produced by the compiler: if you’re using a Swift 2.2 compiler, the second &lt;code&gt;print()&lt;/code&gt; line won’t even be seen. This means you can use utter gibberish if you want:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#if swift(&amp;gt;=2.2)
print(&amp;quot;Running Swift 2.2 or later&amp;quot;)
#else
THIS WILL COMPILE JUST FINE IF YOU&amp;apos;RE
USING A SWIFT 2.2 COMPILER BECAUSE
THIS BIT IS COMPLETELY IGNORED!
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##New documentation keywords: recommended, recommendedover, and keyword&lt;br&gt;Swift supports Markdown-formatted comments to add metadata to your code, so you can write things like this:&lt;br&gt;    /**&lt;br&gt;    Say hello to a specific person&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- parameters:
- name: The name of the person to greet
- returns: Absolutely nothing
- authors:
Paul Hudson
Bilbo Baggins
- bug: This is a deeply dull function
*/
func sayHello(name: String) {
    print(&amp;quot;Hello, \(name)!&amp;quot;)
}

sayHello(&amp;quot;Bob&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This metadata gets used in code completion (“Say hello to a specific person” gets shown as you type) and also in the quick help pane, which is where the other data is shown.&lt;br&gt;In Swift 2.2, three new keywords have been added: &lt;code&gt;recommended&lt;/code&gt;, &lt;code&gt;recommendedover&lt;/code&gt;, and &lt;code&gt;keyword&lt;/code&gt;. These appear to be designed to make code completion more useful by letting you specify which properties and methods should return matches inside Xcode, but right now it doesn’t appear to be working so that’s only a hunch.&lt;br&gt;When things do suddenly spring into life – soon, I hope! – you can use them like this:&lt;br&gt;    /**&lt;br&gt;    Greets a named person&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- keyword: greeting
- recommendedover: sayHelloToPaul
*/
func sayHello(name: String) { }

/**
Always greets the same person
- recommended: sayHello
*/
func sayHelloToPaul() { }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, &lt;code&gt;recommended&lt;/code&gt; lets you say “prefer this other method instead”, whereas &lt;code&gt;recommendedover&lt;/code&gt; lets you say “prefer me over this other method.”&lt;br&gt;Like I said, these don’t appear to be functional in the current Xcode 7.3, but I filed a bug with Apple in the hope of getting some clarity around what these do, and will update this page when I find out more.&lt;br&gt;On the plus side, Xcode 7.3 does feature all-new code completion: you can now type something like “strapp” to have “stringByAppendingString” highlighted in the code completion, or “uitavc” to have “UITableViewCell” highlighted. It will take a little thinking to rewire your brain to use these text shortcuts, but it does promise a significant speed up for your coding.&lt;/p&gt;
</content>
    
    <summary type="html">
    
       What&#39;s new in Swift 2.2 
    
    </summary>
    
      <category term="swift2.2" scheme="http://offbye.com/categories/swift2-2/"/>
    
    
  </entry>
  
  <entry>
    <title>java8新特性介绍</title>
    <link href="http://offbye.com/2016/03/16/java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://offbye.com/2016/03/16/java8新特性介绍/</id>
    <published>2016-03-16T10:30:00.000Z</published>
    <updated>2016-05-12T16:40:03.000Z</updated>
    
    <content type="html">&lt;p&gt;个人感觉Swift比Java 8的新特性还要强大一些，2016年秋季Android N就要支持Java 8了，期待中&lt;/p&gt;
&lt;p&gt;欢迎阅读我的java8新特性介绍教程。本教程将一步一步的引领你浏览所有新的语言特性。伴随着一些简单且简短的代码示例，你将学习如何使用默认接口方法，lambda表示式，方法引用和可重复的annotation。 在阅读完本篇文章，你将对新加入的和更新的API有着更详细的了解。这些API包括流、功能接口、扩展的map以及新的Date API。&lt;/p&gt;
&lt;p&gt;##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;接口的默认方法&lt;br&gt;Java8允许开发者通过使用关键字 default  向接口中加入非抽象方法。这一新的特性被称之为扩展方法。下面是我们的第一个例子：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. interface Formula {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;double calculate(int a);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;default double sqrt(int a) {  &lt;/li&gt;
&lt;li&gt;return Math.sqrt(a);  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在抽象方法calculator之外，接口Formula还定义了一个默认方法sqrt。实现类只需要实现抽象方法calculate。默认方法sqrt可以在定义之外使用。如：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Formula formula = new Formula() {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@Override  &lt;/li&gt;
&lt;li&gt;public double calculate(int a) {  &lt;/li&gt;
&lt;li&gt;return sqrt(a * 100);  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;};  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;formula.calculate(100);     // 100.0  &lt;/li&gt;
&lt;li&gt;formula.sqrt(16);           // 4.0  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;formula被实现为一个匿名类。代码有点啰嗦：六行代码里就就只有一句简单的计算：sqrt(a&lt;em&gt;100)。我们将在下面部分看到一种用java8实现的更加简洁的办法。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Lambda表达式&lt;br&gt;让我们使用一个简单的例子来展示在java8以前是如何对字符串列表进行排序的：&lt;em&gt;*[java]&lt;/em&gt;&lt;/em&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. List&lt;string&gt; names = Arrays.asList(“peter”, “anna”, “mike”, “xenia”);  &lt;/string&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Collections.sort(names, new Comparator&lt;string&gt;() {  &lt;/string&gt;&lt;/li&gt;
&lt;li&gt;@Override  &lt;/li&gt;
&lt;li&gt;public int compare(String a, String b) {  &lt;/li&gt;
&lt;li&gt;return b.compareTo(a);  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;});  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个静态工具方法Collections.sort接受一个列表和一个用于元素比较的比较器。你会发现自己会经常创建匿名类并把它们传递给排序方法。为了不用整天创建这些匿名类，java8带来了一个非常简短的语法–lambda表达式：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Collections.sort(names, (String a, String b) -&amp;gt; {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;return b.compareTo(a);  &lt;/li&gt;
&lt;li&gt;});  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在的代码已经变得简短和便于阅读。但是，实际上，它可以变得更加简短：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Collections.sort(names, (String a, String b) -&amp;gt; b.compareTo(a));  &lt;/p&gt;
&lt;p&gt;对于这种一行代码体的表达式，你可以直接省略掉大括号{}和return关键字。它就变成下面这种更加简短的写法：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Collections.sort(names, (a, b) -&amp;gt; b.compareTo(a));  &lt;/p&gt;
&lt;p&gt;java编译器能够探测到这些参数的类型，这样使得的你可以直接跳过它们。下面我们来解答为什么lambda表示式可以这样随意的使用。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;功能性接口&lt;br&gt;lambda表达式是如何和java系统的类型进行对应的？每个lambda表达式都对应一个指定的类型，这个指定的类型是由接口确定的。该接口被称之为功能性接口，它必须且恰好只包含一个抽象方法声明。被指定接口类型所对应的lambda表达式刚好和这个接口的抽象方法想匹配。因为默认方法不是抽象的，因此你可以在你的功能性接口中添加多个默认方法。&lt;br&gt;我们可以将任意的接口用作lambda表示式，只要该接口仅仅包含一个抽象方法。为了确保你定义的接口达到要求，你可以在接口上添加@FunctionInterface注解。编译器可以检测到该注解并判断你的接口是否满足条件，如果 你定义的接口包含多个抽象方法时，编译器便会报错。&lt;br&gt;示例：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. @FunctionalInterface  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;interface Converter&lt;f, t=&quot;&quot;&gt; {  &lt;/f,&gt;&lt;/li&gt;
&lt;li&gt;T convert(F from);  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Converter&lt;string, integer=&quot;&quot;&gt; converter = (from) -&amp;gt; Integer.valueOf(from);  &lt;/string,&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Integer converted = converter.convert(“123”);  &lt;/li&gt;
&lt;li&gt;System.out.println(converted);    // 123  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果FunctionInterface注解被添加，你定义的接口将总会被检测。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;方法和构造函数引用&lt;br&gt;前部分的示例在使用静态方法引用的情况下可以被进一步的简化：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Converter&lt;string, integer=&quot;&quot;&gt; converter = Integer::valueOf;  &lt;/string,&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Integer converted = converter.convert(“123”);  &lt;/li&gt;
&lt;li&gt;System.out.println(converted);   // 123  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java8可以让你通过关键字::来传递方法和构造函数的引用。上面的示例展示了如何引用一个静态方法。我们同样也可以引用对象方法。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. class Something {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String startsWith(String s) {  &lt;/li&gt;
&lt;li&gt;return String.valueOf(s.charAt(0));  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Something something = new Something();  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Converter&lt;string, string=&quot;&quot;&gt; converter = something::startsWith;  &lt;/string,&gt;&lt;/li&gt;
&lt;li&gt;String converted = converter.convert(“Java”);  &lt;/li&gt;
&lt;li&gt;System.out.println(converted);    // “J”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在我们将看到关键字::如何为构造函数工作。首先我们定义一个拥有不同构造函数的bean类：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. class Person {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;String firstName;  &lt;/li&gt;
&lt;li&gt;String lastName;  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Person() {}  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Person(String firstName, String lastName) {  &lt;/li&gt;
&lt;li&gt;this.firstName = firstName;  &lt;/li&gt;
&lt;li&gt;this.lastName = lastName;  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来我们定义一个用来创建类person的工厂接口：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. &lt;pre code_snippet_id=&quot;265470&quot; snippet_file_name=&quot;blog_20140330_13_2612710&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;interface PersonFactory&lt;p extends=&quot;&quot; person=&quot;&quot;&gt; {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;P create(String firstName, String lastName);  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不使用通常的手动实现工厂类，我们通过使用构造函数将所有的工作联合在一起：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. PersonFactory&lt;person&gt; personFactory = Person::new;  &lt;/person&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Person person = personFactory.create(“Peter”, “Parker”);  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们通过Person::new创建一个指向Person构造函数的引用。java编译器自动的选择正确的构造函数来匹配PersonFactory.create的函数签名。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Lambda范围&lt;br&gt;在lambda表达式里访问外部变量和匿名类的方式是十分相似的。你可以在lambda中访问外部的final变量，访问实例字段和静态变量的方法也是如此。###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;访问本地变量&lt;br&gt;我们可以访问在lambda表示式之外的本地final变量：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. final int num = 1;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Converter&lt;integer, string=&quot;&quot;&gt; stringConverter =  &lt;/integer,&gt;&lt;/li&gt;
&lt;li&gt;(from) -&amp;gt; String.valueOf(from + num);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;stringConverter.convert(2);     // 3  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是和匿名变量不同的是变量num不必强制的被声明为final。下面的代码依然是合法的：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. int num = 1;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Converter&lt;integer, string=&quot;&quot;&gt; stringConverter =  &lt;/integer,&gt;&lt;/li&gt;
&lt;li&gt;(from) -&amp;gt; String.valueOf(from + num);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;stringConverter.convert(2);     // 3  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是实际上，变量num在编译期是被隐式的转换为fianl类型的。下面的代码是不能被成功的编译的：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. int num = 1;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Converter&lt;integer, string=&quot;&quot;&gt; stringConverter =  &lt;/integer,&gt;&lt;/li&gt;
&lt;li&gt;(from) -&amp;gt; String.valueOf(from + num);  &lt;/li&gt;
&lt;li&gt;num = 3;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在lambda表达式内部向变量num写入值同样是不允许的。###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;访问对象字段和静态变量&lt;br&gt;和访问本地变量相反，我们在lambda表达式里即可以读取也可以写入对象字段和静态变量。这一准则同样适用于匿名类。&lt;br&gt;&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. class Lambda4 {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;static int outerStaticNum;  &lt;/li&gt;
&lt;li&gt;int outerNum;  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;void testScopes() {  &lt;/li&gt;
&lt;li&gt;Converter&lt;integer, string=&quot;&quot;&gt; stringConverter1 = (from) -&amp;gt; {  &lt;/integer,&gt;&lt;/li&gt;
&lt;li&gt;outerNum = 23;  &lt;/li&gt;
&lt;li&gt;return String.valueOf(from);  &lt;/li&gt;
&lt;li&gt;};  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Converter&lt;integer, string=&quot;&quot;&gt; stringConverter2 = (from) -&amp;gt; {  &lt;/integer,&gt;&lt;/li&gt;
&lt;li&gt;outerStaticNum = 72;  &lt;/li&gt;
&lt;li&gt;return String.valueOf(from);  &lt;/li&gt;
&lt;li&gt;};  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;访问接口默认方法&lt;br&gt;还记得第一部分的formula示例么？接口formula定义了一个默认方法sqrt，这个方法可以被formula的实例和匿名实例所访问。但是这个方法不能被lambda表达式所访问。&lt;br&gt;默认方法不能被lambda表示式内部的代码访问。下面的代码不能通过编译。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Formula formula = (a) -&amp;gt; sqrt( a * 100);  &lt;/p&gt;
&lt;p&gt;##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;内建的功能性接口&lt;br&gt;JDK1.8包括了许多功能性接口。它们中的一些是老版本中被熟知的接口，例如Comparator和Runnable。这些已存在的接口已经通过@FunctionalInterface注解扩展为支持Lambda表达式。&lt;br&gt;同时Java8的API也包含了很多新的功能性接口简化你的开发。一些新的接口是来自非常出名的Google Guava库。即使你已经对这库十分熟悉了，你也应当留意下这些接口是如何被扩展的。###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;断言接口（Predicates）&lt;br&gt;Predicates是只拥有一个参数的Boolean型功能的接口。这个接口拥有多个默认方法用于构成predicates复杂的逻辑术语。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Predicate&lt;string&gt; predicate = (s) -&amp;gt; s.length() &amp;gt; 0;  &lt;/string&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;predicate.test(“foo”);              // true  &lt;/li&gt;
&lt;li&gt;predicate.negate().test(“foo”);     // false  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Predicate&lt;boolean&gt; nonNull = Objects::nonNull;  &lt;/boolean&gt;&lt;/li&gt;
&lt;li&gt;Predicate&lt;boolean&gt; isNull = Objects::isNull;  &lt;/boolean&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Predicate&lt;string&gt; isEmpty = String::isEmpty;  &lt;/string&gt;&lt;/li&gt;
&lt;li&gt;Predicate&lt;string&gt; isNotEmpty = isEmpty.negate();  &lt;/string&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;功能接口（Functions）&lt;br&gt;Functions接受一个参数并产生一个结果。默认方法能够用于将多个函数链接在一起。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Function&lt;string, integer=&quot;&quot;&gt; toInteger = Integer::valueOf;  &lt;/string,&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Function&lt;string, string=&quot;&quot;&gt; backToString = toInteger.andThen(String::valueOf);  &lt;/string,&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;backToString.apply(“123”);     // “123”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;供应接口（Suppliers）&lt;br&gt;Suppliers对于给定的泛型类型产生一个实例。不同于Functions，Suppliers不需要任何参数。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Supplier&lt;person&gt; personSupplier = Person::new;  &lt;/person&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;personSupplier.get();   // new Person  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;消费接口（Consumers）&lt;br&gt;Consumers代表在只有一个输入参数时操作被如何执行。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Consumer&lt;person&gt; greeter = (p) -&amp;gt; System.out.println(“Hello, “ + p.firstName);  &lt;/person&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;greeter.accept(new Person(“Luke”, “Skywalker”));  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;比较接口（Comparators）&lt;br&gt;Comparators在老版本中就已经被熟知。Java8向该接口中添加了多种默认方法。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Comparator&lt;person&gt; comparator = (p1, p2) -&amp;gt; p1.firstName.compareTo(p2.firstName);  &lt;/person&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Person p1 = new Person(“John”, “Doe”);  &lt;/li&gt;
&lt;li&gt;Person p2 = new Person(“Alice”, “Wonderland”);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;comparator.compare(p1, p2);             // &amp;gt; 0  &lt;/li&gt;
&lt;li&gt;comparator.reversed().compare(p1, p2);  // &amp;lt; 0  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;选项接口（Optionals）&lt;br&gt;Optionals并不是功能性接口，反而它是一种特殊的工具用来阻止NullPointerException。我们首先快速的浏览Optionals是如何工作的，因为它在下一章节是十分重要的概念。&lt;br&gt;Optional是一种可以包含null和non-null值的简单容器。考虑到方法可以返回non-null结果，偶尔也可能任何都不返回。在Java8中，你可以返回Optional而不是返回null。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Optional&lt;string&gt; optional = Optional.of(“bam”);  &lt;/string&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;optional.isPresent();           // true  &lt;/li&gt;
&lt;li&gt;optional.get();                 // “bam”  &lt;/li&gt;
&lt;li&gt;optional.orElse(“fallback”);    // “bam”  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;optional.ifPresent((s) -&amp;gt; System.out.println(s.charAt(0)));     // “b”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;流接口（Streams）&lt;br&gt;java.util.Stream代表着一串你可以在其上进行多种操作的元素。流操作既可以是连续的也可以是中断的。中断操作返回操作结果。而连续操作返回流本身，这样你就可以在该行上继续操作。流是创建在数据源上的，例如：java.util.Collection、list集合和set集合。流操作既可以顺序执行也可以并行执行。我们首先了解下顺序的流是如何工作的。我们首先创建一个字符串链表。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. List&lt;string&gt; stringCollection = new ArrayList&amp;lt;&amp;gt;();  &lt;/string&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stringCollection.add(“ddd2”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“aaa2”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“bbb1”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“aaa1”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“bbb3”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“ccc”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“bbb2”);  &lt;/li&gt;
&lt;li&gt;stringCollection.add(“ddd1”);  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java8的Collections类已经被扩展了，你可以简单的调用Collection.stream()或者Collection.parallelSteam()来创建流。下面部分将介绍大部分流操作。###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Filter&lt;br&gt;Filter接受一个predicate来过滤流中的所有元素。这个操作是连续的，它可以让我们在结果上继续调用另外一个流操作forEach。ForEach接受一个consumer，它被用来对过滤流中的每个元素执行操作。ForEach是一个中断操作，因此我们不能在ForEach后调用其他流操作。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. stringCollection  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.filter((s) -&amp;gt; s.startsWith(“a”))  &lt;/li&gt;
&lt;li&gt;.forEach(System.out::println);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;// “aaa2”, “aaa1”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Sorted&lt;br&gt;Sorted是一个连续操作，它返回流的已排序版本。如果你没有显示的指定Comparator，那么流中元素的排序规则为默认的。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. stringCollection  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.sorted()  &lt;/li&gt;
&lt;li&gt;.filter((s) -&amp;gt; s.startsWith(“a”))  &lt;/li&gt;
&lt;li&gt;.forEach(System.out::println);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;// “aaa1”, “aaa2”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是sorted只创建了流的排序结果，它并没有改变集合中元素的排序位置。stringCollection中元素排序是没有改变的。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. System.out.println(stringCollection);  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Map&lt;br&gt;连续性操作map通过指定的Function将流中的每个元素转变为另外的对象。下面的示例将每个字符串转换为大写的字符串。此外，你也可以使用map将每个元素的类型改变为其它类型。转换后流的泛型类型依赖于你传入的Function的泛型类型。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. stringCollection  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.map(String::toUpperCase)  &lt;/li&gt;
&lt;li&gt;.sorted((a, b) -&amp;gt; b.compareTo(a))  &lt;/li&gt;
&lt;li&gt;.forEach(System.out::println);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;// “DDD2”, “DDD1”, “CCC”, “BBB3”, “BBB2”, “AAA2”, “AAA1”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Match&lt;br&gt;各种匹配操作可以用来检测是否某种predicate和流中元素相匹配。所有的这些操作是中断的并返回一个boolean结果。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. boolean anyStartsWithA =   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stringCollection  &lt;/li&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.anyMatch((s) -&amp;gt; s.startsWith(“a”));  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;System.out.println(anyStartsWithA);      // true  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;boolean allStartsWithA =   &lt;/li&gt;
&lt;li&gt;stringCollection  &lt;/li&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.allMatch((s) -&amp;gt; s.startsWith(“a”));  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;System.out.println(allStartsWithA);      // false  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;boolean noneStartsWithZ =   &lt;/li&gt;
&lt;li&gt;stringCollection  &lt;/li&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.noneMatch((s) -&amp;gt; s.startsWith(“z”));  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;System.out.println(noneStartsWithZ);      // true  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Count&lt;br&gt;Count是中断型操作，它返回流中的元素数量。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. long startsWithB =   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stringCollection  &lt;/li&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.filter((s) -&amp;gt; s.startsWith(“b”))  &lt;/li&gt;
&lt;li&gt;.count();  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;System.out.println(startsWithB);    // 3  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Reduce&lt;br&gt;这个中断性操作使用指定的function对流中元素实施消减策略。此操作的返回值是一个包括所有被消减元素的Optional。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Optional&lt;string&gt; reduced =  &lt;/string&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stringCollection  &lt;/li&gt;
&lt;li&gt;.stream()  &lt;/li&gt;
&lt;li&gt;.sorted()  &lt;/li&gt;
&lt;li&gt;.reduce((s1, s2) -&amp;gt; s1 + “#” + s2);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;reduced.ifPresent(System.out::println);  &lt;/li&gt;
&lt;li&gt;// “aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2”  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Parallel Streams&lt;br&gt;在前面部分我们提到流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。&lt;br&gt;随后的例子我们展示了并行流可以多么容易的提高性能。&lt;br&gt;首先，我们创建一个包含唯一元素的大容器：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. int max = 1000000;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;List&lt;string&gt; values = new ArrayList&amp;lt;&amp;gt;(max);  &lt;/string&gt;&lt;/li&gt;
&lt;li&gt;for (int i = 0; i &amp;lt; max; i++) {  &lt;/li&gt;
&lt;li&gt;UUID uuid = UUID.randomUUID();  &lt;/li&gt;
&lt;li&gt;values.add(uuid.toString());  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在我们开始测试排序这些元素需要多长时间。&lt;br&gt;Sequential Sort&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. long t0 = System.nanoTime();  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long count = values.stream().sorted().count();  &lt;/li&gt;
&lt;li&gt;System.out.println(count);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long t1 = System.nanoTime();  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);  &lt;/li&gt;
&lt;li&gt;System.out.println(String.format(“sequential sort took: %d ms”, millis));  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;// sequential sort took: 899 ms  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Parallel Sort&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. long t0 = System.nanoTime();  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long count = values.parallelStream().sorted().count();  &lt;/li&gt;
&lt;li&gt;System.out.println(count);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long t1 = System.nanoTime();  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);  &lt;/li&gt;
&lt;li&gt;System.out.println(String.format(“parallel sort took: %d ms”, millis));  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;// parallel sort took: 472 ms  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你会观察到这两种模式的代码基本上市一致的，但是并行排序所花费的时间大约是顺序排序的一半。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Map&lt;br&gt;我们已经提到maps不支持流。然而现在maps包括了许多新的非常有用的方法用于执行通用任务。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Map&lt;integer, string=&quot;&quot;&gt; map = new HashMap&amp;lt;&amp;gt;();  &lt;/integer,&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;for (int i = 0; i &amp;lt; 10; i++) {  &lt;/li&gt;
&lt;li&gt;map.putIfAbsent(i, “val” + i);  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;map.forEach((id, val) -&amp;gt; System.out.println(val));  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. &lt;/p&gt;&lt;/pre&gt;上述的代码应该很清晰了：putIfAbsent使得我们不用写是否为null值的检测语句；forEach使用consumer来对map中的每个元素进行操作。&lt;div&gt;&lt;/div&gt;&lt;div&gt;下面的例子向我们展示使用功能性函数在map里执行代码：&lt;/div&gt;&lt;div&gt;&lt;pre code_snippet_id=&quot;265470&quot; snippet_file_name=&quot;blog_20140330_37_9422552&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;map.computeIfPresent(3, (num, val) -&amp;gt; val + num);  &lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;map.get(3);             // val33  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;map.computeIfPresent(9, (num, val) -&amp;gt; null);  &lt;/li&gt;
&lt;li&gt;map.containsKey(9);     // false  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;map.computeIfAbsent(23, num -&amp;gt; “val” + num);  &lt;/li&gt;
&lt;li&gt;map.containsKey(23);    // true  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;map.computeIfAbsent(3, num -&amp;gt; “bam”);  &lt;/li&gt;
&lt;li&gt;map.get(3);             // val33  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们将学习如何删除给定键所对应的元素。删除操作还需要满足给定的值需要和map中的值想等：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. map.remove(3, “val3”);  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;map.get(3);             // val33  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;map.remove(3, “val33”);  &lt;/li&gt;
&lt;li&gt;map.get(3);             // null  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他一些帮助性方法：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. map.getOrDefault(42, “not found”);  // not found  &lt;/p&gt;
&lt;p&gt;合并map中的实体是十分容易的：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. map.merge(9, “val9”, (value, newValue) -&amp;gt; value.concat(newValue));  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;map.get(9);             // val9  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;map.merge(9, “concat”, (value, newValue) -&amp;gt; value.concat(newValue));  &lt;/li&gt;
&lt;li&gt;map.get(9);             // val9concat  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果map不存在指定的键，那么它将把该键值对key/value加入map中。反而，如果存在，它将调用function来进行合并操作。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Date API&lt;br&gt;Java8在包java.time下面包括了一款新的date和time的API。新的Date API和Joda-Time库是相兼容的，但是它们不是一样的。下面的示例覆盖了新API中的重要部分。###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Clock&lt;br&gt;Clock提供了访问当前日期和时间的方法。Clock是时区敏感的并且它可以被用来替代System.currentTimeMillis进行获取当前毫秒数。同时，时间轴上的时间点是可以用类Instant来表示的。Instants可以被用来创建遗留的java.util.Date对象。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Clock clock = Clock.systemDefaultZone();  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;long millis = clock.millis();  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Instant instant = clock.instant();  &lt;/li&gt;
&lt;li&gt;Date legacyDate = Date.from(instant);   // legacy java.util.Date  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;TimeZones&lt;br&gt;TimeZones被用来表示ZoneId。它们可以通过静态工厂方法访问。TImeZones定义了时差，它在instants和本地日期时间转换上十分重要。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. System.out.println(ZoneId.getAvailableZoneIds());  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;// prints all available timezone ids  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;ZoneId zone1 = ZoneId.of(“Europe/Berlin”);  &lt;/li&gt;
&lt;li&gt;ZoneId zone2 = ZoneId.of(“Brazil/East”);  &lt;/li&gt;
&lt;li&gt;System.out.println(zone1.getRules());  &lt;/li&gt;
&lt;li&gt;System.out.println(zone2.getRules());  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;// ZoneRules[currentStandardOffset=+01:00]  &lt;/li&gt;
&lt;li&gt;// ZoneRules[currentStandardOffset=-03:00]  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;LocalTime&lt;br&gt;本地时间代表了一个和时区无关的时间，e.g. 10pm or 17:30:15. 下面的示例创建了前部分展示的两个时区的本地时间。然后，我们将比较这两个时间并计算出这两个时间在小时和分钟数上的差异。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. LocalTime now1 = LocalTime.now(zone1);  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LocalTime now2 = LocalTime.now(zone2);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;System.out.println(now1.isBefore(now2));  // false  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long hoursBetween = ChronoUnit.HOURS.between(now1, now2);  &lt;/li&gt;
&lt;li&gt;long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;System.out.println(hoursBetween);       // -3  &lt;/li&gt;
&lt;li&gt;System.out.println(minutesBetween);     // -239  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LocalTime包含了多个工厂方法用来简化创建过程，其中也包括通过字符串来创建时间：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. LocalTime late = LocalTime.of(23, 59, 59);  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;System.out.println(late);       // 23:59:59  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;DateTimeFormatter germanFormatter =  &lt;/li&gt;
&lt;li&gt;DateTimeFormatter  &lt;/li&gt;
&lt;li&gt;.ofLocalizedTime(FormatStyle.SHORT)  &lt;/li&gt;
&lt;li&gt;.withLocale(Locale.GERMAN);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;LocalTime leetTime = LocalTime.parse(“13:37”, germanFormatter);  &lt;/li&gt;
&lt;li&gt;System.out.println(leetTime);   // 13:37  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;LocalDate&lt;br&gt;LocalDate代表了一个可区分日期，e.g. 2014-03-11。 它是不变的同时工作原理类似于LocalTime。下面的例子描绘了通过加减年，月，日来计算出一个新的日期。需要注意的是这每个操作都返回一个新的实例。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. LocalDate today = LocalDate.now();  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);  &lt;/li&gt;
&lt;li&gt;LocalDate yesterday = tomorrow.minusDays(2);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);  &lt;/li&gt;
&lt;li&gt;DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();  &lt;/li&gt;
&lt;li&gt;System.out.println(dayOfWeek);    // FRIDAY  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从字符串解析出LocalDate和解析LocalTime一样简单：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. DateTimeFormatter germanFormatter =  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DateTimeFormatter  &lt;/li&gt;
&lt;li&gt;.ofLocalizedDate(FormatStyle.MEDIUM)  &lt;/li&gt;
&lt;li&gt;.withLocale(Locale.GERMAN);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;LocalDate xmas = LocalDate.parse(“24.12.2014”, germanFormatter);  &lt;/li&gt;
&lt;li&gt;System.out.println(xmas);   // 2014-12-24  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###&lt;a href=&quot;&quot;&gt;&lt;/a&gt;LocalDateTime&lt;br&gt;LocalDateTime代表日期和时间。它将我们前部分看到的时间和日期组合进一个实例。LocalDateTime是不可变的并且它的工作原理和LocalTime和LocalDate十分相似。我们可以从date-time中获取某些字段值：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;DayOfWeek dayOfWeek = sylvester.getDayOfWeek();  &lt;/li&gt;
&lt;li&gt;System.out.println(dayOfWeek);      // WEDNESDAY  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Month month = sylvester.getMonth();  &lt;/li&gt;
&lt;li&gt;System.out.println(month);          // DECEMBER  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);  &lt;/li&gt;
&lt;li&gt;System.out.println(minuteOfDay);    // 1439  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一些额外的时区信息帮助下，它可以被转换为instant。Instants可以被容易的转换为遗留的java.util.Date类型。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Instant instant = sylvester  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;.atZone(ZoneId.systemDefault())  &lt;/li&gt;
&lt;li&gt;.toInstant();  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Date legacyDate = Date.from(instant);  &lt;/li&gt;
&lt;li&gt;System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;格式date-time的过程和格式date和time基本上是一样的。在使用系统自带的定义格式时，我们也可以定义我们自己的格式：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. DateTimeFormatter formatter =  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DateTimeFormatter  &lt;/li&gt;
&lt;li&gt;.ofPattern(“MMM dd, yyyy - HH:mm”);  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;LocalDateTime parsed = LocalDateTime.parse(“Nov 03, 2014 - 07:13”, formatter);  &lt;/li&gt;
&lt;li&gt;String string = formatter.format(parsed);  &lt;/li&gt;
&lt;li&gt;System.out.println(string);     // Nov 03, 2014 - 07:13  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和java.text.NumberFormat不一样的是DateTimeFormatter是不可变的并且是类型安全的。&lt;br&gt;如果想了解详细的格式语法，可以阅读&lt;a href=&quot;http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。##&lt;a href=&quot;&quot;&gt;&lt;/a&gt;Annotations&lt;br&gt;Java8中的Annotations是可重复。现在我们深入的学习一个例子来理解它。&lt;br&gt;首先，我们定义一个包装注解，它包含了一个实际注解的数组。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. @interface Hints {  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hint[] value();  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;@Repeatable(Hints.class)  &lt;/li&gt;
&lt;li&gt;@interface Hint {  &lt;/li&gt;
&lt;li&gt;String value();  &lt;/li&gt;
&lt;li&gt;}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java8可以使同一个注解类型同时使用多次，只要我们在注解声明时使用@Repeatable。&lt;br&gt;情景1：使用容器注解&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. @Hints({@Hint(“hint1”), @Hint(“hint2”)})  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;class Person {}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;情景2：使用可重复注解&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. @Hint(“hint1”)  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@Hint(“hint2”)  &lt;/li&gt;
&lt;li&gt;class Person {}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在第二种情景下，java编译器隐式的在该注解使用中加入@Hints。这种后期处理在通过反射获取注解是十分重要的。&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. Hint hint = Person.class.getAnnotation(Hint.class);  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;System.out.println(hint);                   // null  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Hints hints1 = Person.class.getAnnotation(Hints.class);  &lt;/li&gt;
&lt;li&gt;System.out.println(hints1.value().length);  // 2  &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);  &lt;/li&gt;
&lt;li&gt;System.out.println(hints2.length);          // 2  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然我们从来没有在类Person上声明@Hints注解，但该信息还是可以通过getAnnotation(Hint.class)获得。　此外，getAnnotationsByType是一种更加便利的方法，它可以保证我们访问所有使用的@Hint注解。&lt;br&gt;此外，Java8中注解的使用范围扩展到两种新的类型：&lt;strong&gt;[java]&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;view plain&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;view plain&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;copy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;copy&lt;/a&gt; &lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;print&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;print&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/jessenpan/article/details/22580339#&quot; title=&quot;?&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;?&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470&quot; title=&quot;在CODE上查看代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/CODE_ico.png&quot; alt=&quot;在CODE上查看代码片&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://code.csdn.net/snippets/265470/fork&quot; title=&quot;派生到我的代码片&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://code.csdn.net/assets/ico_fork.svg&quot; alt=&quot;派生到我的代码片&quot;&gt;&lt;/a&gt;1. @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@interface MyAnnotation {}  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结我的Java8语言特性教程到此就结束了。此外还有很多新的内容需要阐述。去不去了解JDK8中的这些非常棒的特性取决于你，这些特性包括有Arrays.parallelSort，StampedLock，CompletableFuture  —即使列举名字也有很多了。我已经在网站上把这些特性都列举出来了，你可以去哪里看看。&lt;br&gt;&lt;a href=&quot;http://winterbe.com/projects/java8-explorer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java SE 8 API Explorer&lt;/a&gt;&lt;br&gt;原文地址: &lt;a href=&quot;http://winterbe.com/posts/2014/03/16/java-8-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://winterbe.com/posts/2014/03/16/java-8-tutorial/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       java8新特性介绍 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift异常处理：throw和rethrow</title>
    <link href="http://offbye.com/2016/03/15/Swift%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9Athrow%E5%92%8Crethrow/"/>
    <id>http://offbye.com/2016/03/15/Swift异常处理：throw和rethrow/</id>
    <published>2016-03-15T11:00:00.000Z</published>
    <updated>2016-05-12T16:40:04.000Z</updated>
    
    <content type="html">&lt;p&gt;Swift异常处理体现了函数式语言的特性，因此我们可以传一个会抛出异常的函数闭包（高阶函数）作为参数传到另一个函数中（父函数），父函数可以在子函数抛出异常时直接向上抛出异常，这时用rethrow关键字表示引用闭包时抛出的异常。throw关键字和Java一样，就是说调用这个函数本身可能会抛出异常。rethrow可以看作是throw的子集，Swift不把rethrow作为完整的类型。例如一个函数不能同时用throw和rethrow抛出异常，高阶函数闭包定义中也不能包含rethrow。rethrow更像函数的属性（类似@noreturn），rethrow只是在函数作为参数调用的上下文中才有意义，就是为了简化语法的。一个接受闭包作为参数的函数有下面三种throw选择&lt;br&gt;1、throw异常，这表示这个函数可能会抛出异常，无论作为参数的闭包是否抛出异常2、rethrow异常，这表示这个函数本身不会抛出异常，但如果作为参数的闭包抛出了异常，那么它会把异常继续抛上去。例如&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func map&amp;lt;T&amp;gt;(@noescape transform: (Generator.Element) throws -&amp;gt; T) rethrows -&amp;gt; [T]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、不抛出异常，这表示这个函数会处理参数闭包的异常，或者不对闭包进行运算。&lt;/p&gt;
&lt;p&gt;当我们使用Swift异常处理时，应该不认为它是抛出异常，而是返回不同的类型&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;http://robnapier.net/re-throws&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://robnapier.net/re-throws&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Swift异常处理：throw和rethrow 
    
    </summary>
    
      <category term="swift" scheme="http://offbye.com/categories/swift/"/>
    
      <category term="异常处理" scheme="http://offbye.com/categories/swift/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift iOS- 手势检测详解</title>
    <link href="http://offbye.com/2016/03/14/Swift%20iOS-%20%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://offbye.com/2016/03/14/Swift iOS- 手势检测详解/</id>
    <published>2016-03-14T10:58:00.000Z</published>
    <updated>2016-05-12T16:40:04.000Z</updated>
    
    <content type="html">&lt;p&gt;UIGestureRecognizer有许多子类，用于监听一些常见的手势事件，这些子类主要有：&lt;br&gt;1，UISwipeGestureRecognizer：滑动（快速移动）123456789101112131415161718&lt;code&gt;class&lt;/code&gt; &lt;code&gt;ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{`` &lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``let&lt;/code&gt; &lt;code&gt;swipe = ``UISwipeGestureRecognizer``(target:``self``, action:``Selector``(``&amp;quot;swipe:&amp;quot;``))``        ``swipe.direction = ``UISwipeGestureRecognizerDirection``.``Up``        ``self``.view.addGestureRecognizer(swipe)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;swipe(recognizer:``UISwipeGestureRecognizer``){``        ``print``(``&amp;quot;swipe ok&amp;quot;``)``        ``var&lt;/code&gt; &lt;code&gt;point=recognizer.locationInView(``self``.view)``        ``//这个点是滑动的起点``        ``print``(point.x)``        ``print``(point.y)``    ``}``}&lt;/code&gt;注意1：如果UISwipeGestureRecognizer在不指定方向的时候，默认向右滑动才会触发事件。如果要指定方向，需要设置direction属性12&lt;code&gt;//表示监听滑动的方向为向上``swipe.direction = ``UISwipeGestureRecognizerDirection``.``Up&lt;/code&gt;&lt;br&gt;注意2：有网友问如果各个方向都要响应怎么办，只要多定义几个UISwipeGestureRecognizer就可以了123456789101112131415161718192021222324252627&lt;code&gt;class&lt;/code&gt; &lt;code&gt;ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{`` &lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``let&lt;/code&gt; &lt;code&gt;swipeUp = ``UISwipeGestureRecognizer``(target:``self``, action:``Selector``(``&amp;quot;swipe:&amp;quot;``))``        ``swipeUp.direction = ``UISwipeGestureRecognizerDirection``.``Up``        ``self``.view.addGestureRecognizer(swipeUp)`` &lt;/code&gt; &lt;code&gt;``let&lt;/code&gt; &lt;code&gt;swipeDown = ``UISwipeGestureRecognizer``(target:``self``, action:``Selector``(``&amp;quot;swipe:&amp;quot;``))``        ``swipeDown.direction = ``UISwipeGestureRecognizerDirection``.``Down``        ``self``.view.addGestureRecognizer(swipeDown)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;swipe(recognizer:``UISwipeGestureRecognizer``){``        ``if&lt;/code&gt; &lt;code&gt;recognizer.direction == ``UISwipeGestureRecognizerDirection``.``Up``{``            ``print``(``&amp;quot;向上滑动&amp;quot;``)``        ``}``else&lt;/code&gt; &lt;code&gt;if&lt;/code&gt; &lt;code&gt;recognizer.direction == ``UISwipeGestureRecognizerDirection``.``Down``{``            ``print``(``&amp;quot;向下滑动&amp;quot;``)``        ``}`` &lt;/code&gt; &lt;code&gt;``let&lt;/code&gt; &lt;code&gt;point=recognizer.locationInView(``self``.view)``        ``//这个点是滑动的起点``        ``print``(point.x)``        ``print``(point.y)``    ``}``}&lt;/code&gt;&lt;br&gt;2，UITapGestureRecognizer：轻点手势（点击）&lt;br&gt;（1）可以通过numberOfTouchesRequired属性设置触摸点数，比如设置2表示必须两个手指触摸时才会触发&lt;br&gt;（2）通过numberOfTapsRequired属性设置点击次数，单击设置为1，双击设置为2&lt;br&gt;（3）如果一个控件既监听了单击事件也监听了双击事件，默认当双击事件触发的时候也同时会触发单击事件。如果想双击时不触发单击，需要通过requireGestureRecognizerToFail进行设置&lt;br&gt;1234567891011121314151617181920212223242526272829&lt;code&gt;class&lt;/code&gt; &lt;code&gt;ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{`` &lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``//单击监听``        ``let&lt;/code&gt; &lt;code&gt;tapSingle=``UITapGestureRecognizer``(target:``self``,action:``&amp;quot;tapSingleDid&amp;quot;``)``        ``tapSingle.numberOfTapsRequired=1``        ``tapSingle.numberOfTouchesRequired=1``        ``//双击监听``        ``let&lt;/code&gt; &lt;code&gt;tapDouble=``UITapGestureRecognizer``(target:``self``,action:``&amp;quot;tapDoubleDid:&amp;quot;``)``        ``tapDouble.numberOfTapsRequired=2``        ``tapDouble.numberOfTouchesRequired=1``        ``//声明点击事件需要双击事件检测失败后才会执行``        ``tapSingle.requireGestureRecognizerToFail(tapDouble);``        ``self``.view.addGestureRecognizer(tapSingle)``        ``self``.view.addGestureRecognizer(tapDouble)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;tapSingleDid(){``        ``print``(``&amp;quot;单击了&amp;quot;``)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;tapDoubleDid(sender:``UITapGestureRecognizer``){``        ``if&lt;/code&gt; &lt;code&gt;sender.view == ``self``.view{``                ``print``(``&amp;quot;双击了&amp;quot;``)``        ``}``    ``}   ``}&lt;/code&gt;&lt;br&gt;3，UIPinchGestureRecognizer：捏合手势（两个手指进行放大缩小）1234567891011121314151617&lt;code&gt;class&lt;/code&gt; &lt;code&gt;ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{   `` &lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``//设置监听方法为pinchDid方法``        ``let&lt;/code&gt; &lt;code&gt;pinch=``UIPinchGestureRecognizer``(target:``self``,action:``&amp;quot;pinchDid:&amp;quot;``)``        ``self``.view.addGestureRecognizer(pinch)`` &lt;/code&gt; &lt;code&gt;` &lt;/code&gt;    &lt;code&gt;}&lt;/code&gt;    &lt;code&gt;func` `pinchDid(recognizer:&lt;/code&gt;UIPinchGestureRecognizer&lt;code&gt;)&lt;/code&gt;    &lt;code&gt;{&lt;/code&gt;        &lt;code&gt;//在监听方法中可以实时获得捏合的比例&lt;/code&gt;        &lt;code&gt;print&lt;/code&gt;(recognizer.scale);&lt;code&gt;``}&lt;/code&gt;}&lt;code&gt;4，UIRotationGestureRecognizer：旋转手势（两个手指进行旋转）1234567891011121314&lt;/code&gt;class&lt;code&gt;`ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``let&lt;/code&gt; &lt;code&gt;rotation=``UIRotationGestureRecognizer``(target:``self``,action:``&amp;quot;rotationDid:&amp;quot;``)``        ``self``.view.addGestureRecognizer(rotation)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;rotationDid(recognizer:``UIRotationGestureRecognizer``){``        ``//旋转的弧度转换为角度``        ``print``(recognizer.rotation*(180/``CGFloat``(``M_PI``)))``    ``}``}&lt;/code&gt;&lt;br&gt;5，UIPanGestureRecognizer：拖动手势1234567891011121314151617181920212223&lt;code&gt;class&lt;/code&gt; &lt;code&gt;ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{`` &lt;/code&gt; &lt;code&gt;``var&lt;/code&gt; &lt;code&gt;rect:``UIView``!`` &lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``rect=``UIView``(frame:``CGRectMake``(0, 0, 100, 100))``        ``rect.center=``self``.view.center``        ``rect.backgroundColor=``UIColor``.redColor()``        ``self``.view.addSubview(rect)`` &lt;/code&gt; &lt;code&gt;``let&lt;/code&gt; &lt;code&gt;pan = ``UIPanGestureRecognizer``(target:``self``,action:``&amp;quot;panDid:&amp;quot;``)``        ``pan.maximumNumberOfTouches=1``        ``rect.addGestureRecognizer(pan)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;panDid(recognizer:``UISwipeGestureRecognizer``){``        ``let&lt;/code&gt; &lt;code&gt;point=recognizer.locationInView(``self``.view)``        ``//设置矩形的位置``        ``rect.center=point``    ``}``}&lt;/code&gt;&lt;br&gt;6，UILongPressGestureRecognizer：长按1234567891011121314151617181920&lt;code&gt;import&lt;/code&gt; &lt;code&gt;UIKit&lt;/code&gt; &lt;code&gt;class&lt;/code&gt; &lt;code&gt;ViewController``: ``UIViewController&lt;/code&gt; &lt;code&gt;{`` &lt;/code&gt; &lt;code&gt;``override&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; &lt;code&gt;viewDidLoad() {``        ``super``.viewDidLoad()`` &lt;/code&gt; &lt;code&gt;``//长按监听``        ``let&lt;/code&gt; &lt;code&gt;longPress=``UILongPressGestureRecognizer``(target:``self``,action:``&amp;quot;longPressDid:&amp;quot;``)``        ``self``.view.addGestureRecognizer(longPress)``    ``}`` &lt;/code&gt; &lt;code&gt;``func&lt;/code&gt; &lt;code&gt;longPressDid(sender: ``UILongPressGestureRecognizer``){``        ``if&lt;/code&gt; &lt;code&gt;sender.state == .``Began&lt;/code&gt; &lt;code&gt;{``            ``print``(``&amp;quot;长按响应开始&amp;quot;``)``        ``} ``else&lt;/code&gt; &lt;code&gt;{``            ``print``(``&amp;quot;长按响应结束&amp;quot;``)``        ``}``    ``}``}&lt;/code&gt;&lt;br&gt;原文出自：&lt;a href=&quot;http://www.hangge.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;www.hangge.com&lt;/a&gt;  转载请保留原文链接：&lt;a href=&quot;http://www.hangge.com/blog/cache/detail_546.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.hangge.com/blog/cache/detail_546.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Swift iOS- 手势检测详解 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift化零为整：Reduce 详解</title>
    <link href="http://offbye.com/2016/03/11/Swift%E5%8C%96%E9%9B%B6%E4%B8%BA%E6%95%B4%EF%BC%9AReduce%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://offbye.com/2016/03/11/Swift化零为整：Reduce 详解/</id>
    <published>2016-03-11T06:58:00.000Z</published>
    <updated>2016-05-12T16:40:05.000Z</updated>
    
    <content type="html">&lt;p&gt;即使早在 Swift 正式发布之前，iOS / Cocoa 开发者都可以使用诸如 ObjectiveSugar 或者 ReactiveCocoa 第三方库，实现类似&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatMap&lt;/code&gt; 或 &lt;code&gt;filter&lt;/code&gt; 等函数式编程的构建。而在 Swift 中，这些家伙（&lt;code&gt;map&lt;/code&gt; 等几个函数）已经入驻成为「头等公民」了。比起标准的 &lt;code&gt;for&lt;/code&gt; 循环，使用函数式编程有很多优势。它们通常能够更好地表达你的意图，减少代码的行数，以及使用链式结构构建复杂的逻辑，更显清爽。&lt;br&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;本文中，我将介绍附加于 Swift 中的一个非常酷的函数：「Reduce」。相对于 &lt;code&gt;map&lt;/code&gt; / &lt;code&gt;filter&lt;/code&gt; 函数，&lt;code&gt;reduce&lt;/code&gt; 有时不失为一个更好的解决方案。&lt;/p&gt;
&lt;p&gt;###一个简单的问题&lt;br&gt;思考这么一个问题：你从 JSON 中获取到一个 persons 列表，意图计算所有来自 California 的居民的平均年龄。需要解析的数据如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let persons: [[String: String]] = [[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Carl Saxon&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;New York, NY&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;44&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Travis Downing&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;El Segundo, CA&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;34&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Liz Parker&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;San Francisco, CA&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;32&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;John Newden&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;New Jersey, NY&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;21&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Hector Simons&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;San Diego, CA&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;37&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Brian Neo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;27&quot;&lt;/span&gt;]] &lt;span class=&quot;comment&quot;&gt;//注意这家伙没有 city 键值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意最后一个记录，它遗漏了问题中 person 的居住地 city 。对于这些情况，默默忽略即可…&lt;br&gt;本例中，我们期望的结果是那三位来自 California 的居民。让我们尝试在 Swift 中使用 &lt;code&gt;flatMap&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt; 来实现这个任务。使用 &lt;code&gt;flatMap&lt;/code&gt; 函数替代 &lt;code&gt;map&lt;/code&gt; 函数的原因在于前者能够忽略可选值为 nil 的情况。例如 &lt;code&gt;flatMap([0,nil,1,2,nil])&lt;/code&gt; 的结果是 &lt;code&gt;[0,1,2]&lt;/code&gt;。处理那些没有 city 属性的情况这会非常有用。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func infoFromState(state state: String, persons: [[String: AnyObject]]) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     -&amp;gt; Int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   &lt;span class=&quot;comment&quot;&gt;// 先进行 flatMap 后进行 filter 筛选&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// $0[&quot;city&quot;] 是一个可选值，对于那些没有 city 属性的项返回 nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// componentsSeparatedByString 处理键值，例如 &quot;New York, NY&quot; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 最后返回的 [&quot;New York&quot;,&quot;NY&quot;]，last 取到最后的 NY&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; persons.flatMap( &amp;#123; $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;] &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   .filter(&amp;#123;$&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;hasSuffix(state)&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   .count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;infoFromState(state: &lt;span class=&quot;string&quot;&gt;&quot;CA&quot;&lt;/span&gt;, persons: persons)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//#+RESULTS:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//: 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这非常简单。&lt;br&gt;不过，现在来思考另外一个难题：你想要获悉居住在 California 的人口数，接着计算他们的平均年龄。如果我们想要在上面函数的基础上尝试做修改，立马会发现难度不小。解决方法倒是有几种，不过大都看起来不适用函数式结构解决方案。倒是通过循环的方式能简单的解决这个问题。&lt;br&gt;这时候我们要琢磨为啥不适用了，原因很简单：数据的形式（Shape）改变了。而 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatMap&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt; 函数能够始终保持数据形式的相似性。数组传入，数组返回。当然数组的元素个数和内容可以改变，不过始终是数组形式（Array-shape）。但是，上面所描述的问题要求我们最后转换成的结果是个结构体（Struct），或者说是以元组（Tuple）的形式包含一个整型平均值（平均年龄）和一个整型总和（人口数）。&lt;br&gt;对于这种类型的问题，我们可以使用 &lt;code&gt;reduce&lt;/code&gt; 来救场。&lt;/p&gt;
&lt;p&gt;###Reduce&lt;br&gt;Reduce 是 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatMap&lt;/code&gt; 或 &lt;code&gt;filter&lt;/code&gt; 的一种扩展的形式（译者注：后三个函数能干嘛，reduce 就能用另外一种方式实现）。Reduce 的基础思想是将一个序列转换为一个不同类型的数据，期间通过一个累加器（Accumulator）来持续记录递增状态。为了实现这个方法，我们会向 reduce 方法中传入一个用于处理序列中每个元素的结合（Combinator）闭包 / 函数 / 方法。这听起来有点复杂，不过通过几个例子练手，你就会发现这相当简单。&lt;br&gt;它是 &lt;code&gt;SequenceType&lt;/code&gt; 中的一个方法，看起来是这样的（简化版本）：&lt;br&gt;    funcreduce&lt;t&gt;(initial: T, combine: (T, Self.Generator.Element) -&amp;gt; T) -&amp;gt; T&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;此刻，我们拥有一个初始值（Initial value）以及一个闭包（返回值类型和初始值类型一致）。函数最后的返回值同样和初始值类型一致，为 &lt;code&gt;T&lt;/code&gt;。&lt;br&gt;假设我们现在要实现一个 reduce 操作 — 对一个整数列表值做累加运算，方案如下：&lt;br&gt;    funccombinator(accumulator: Int, current: Int) -&amp;gt; Int {&lt;br&gt;    return accumulator + current&lt;br&gt;    }&lt;br&gt;    [1, 2, 3].reduce(0, combine: combinator)&lt;br&gt;    // 执行步骤如下&lt;br&gt;    combinator(0, 1) { return0 + 1 } = 1&lt;br&gt;    combinator(1, 2) { return1 + 2 } = 3&lt;br&gt;    combinator(3, 3) { return3 + 3 } = 6&lt;br&gt;    = 6&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1, 2, 3]&lt;/code&gt; 中的每个元素都将调用一次结合（Combinator）函数进行处理。同时我们使用累加器（Accumulator）变量实时记录递增状态（递增并非是指加法），这里是一个整型值。&lt;br&gt;接下来，我们重新实现那些函数式编程的「伙伴」（自己来写 map、flatMap 和 filter 函数）。简便起见，所有这些方法都是对&lt;code&gt;Int&lt;/code&gt; 或 &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt; 进行操作的；换言之，我们此刻不考虑泛型。另外牢记下面的实现只是为了展示 &lt;code&gt;reduce&lt;/code&gt; 的实现过程。原生的 Swift 实现相比较下面 reduce 的版本，速度要快很多&lt;a href=&quot;http://swift.gg/2015/12/10/reduce-all-the-things/#1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;。不过，Reduce 能在不同的问题中表现得很好，之后会进一步地详述。&lt;/p&gt;
&lt;p&gt;###Map&lt;br&gt;    // 重新定义一个 map 函数&lt;br&gt;    funcrmap(elements: [Int], transform: (Int) -&amp;gt; Int) -&amp;gt; [Int] {&lt;br&gt;    return elements.reduce(&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;, combine: { (var acc: [Int], obj: Int) -&amp;gt; [Int] in&lt;br&gt;           acc.append(transform(obj))&lt;br&gt;    return acc&lt;br&gt;        })&lt;br&gt;    }&lt;br&gt;    print(rmap([1, 2, 3, 4], transform: { $0 * 2}))&lt;br&gt;    // [2, 4, 6, 8]&lt;/p&gt;
&lt;p&gt;这个例子能够很好地帮助你理解 &lt;code&gt;reduce&lt;/code&gt; 的基础知识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，elements 序列调用 reduce 方法：&lt;code&gt;elements.reduce...&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后，我们传入初始值给累加器（Accumulator），即一个 Int 类型空数组（&lt;code&gt;[Int]()&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;接着，我们传入 &lt;code&gt;combinator&lt;/code&gt; 闭包，它接收两个参数：第一个参数为 accumulator，即 &lt;code&gt;acc: [Int]&lt;/code&gt;；第二个参数为从序列中取得的当前对象 &lt;code&gt;obj: Int&lt;/code&gt;（译者注：对序列进行遍历，每次取到其中的一个对象 obj）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;combinator&lt;/code&gt; 闭包体中的实现代码非常简单。我们对 obj 做变换处理，然后添加到累加器 accumulator 中。最后返回 accumulator 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比较调用 &lt;code&gt;map&lt;/code&gt; 方法，这种实现代码看起来有点冗余。的确如此！但是，上面这个版本相当详细地解释了 &lt;code&gt;reduce&lt;/code&gt; 方法是怎么工作的。我们可以对此进行简化。&lt;br&gt;    funcrmap(elements: [Int], transform: (Int) -&amp;gt; Int) -&amp;gt; [Int] {&lt;br&gt;    // $0 表示第一个传入参数，$1 表示第二个传入参数，依次类推…&lt;br&gt;    return elements.reduce(&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;, combine: {$0 + [transform($1)]})&lt;br&gt;    }&lt;br&gt;    print(rmap([1, 2, 3, 4], transform: { $0 * 2}))&lt;br&gt;    // [2, 4, 6, 8]&lt;/p&gt;
&lt;p&gt;依旧能够正常运行。这个版本都有哪些不同呢？实际上，我们使用了 Swift 中的小技巧，&lt;code&gt;+&lt;/code&gt; 运算符能够对两个序列进行加法操作。因此 &lt;code&gt;[0, 1, 2] + [transform(4)]&lt;/code&gt; 表达式将左序列和右序列进行相加，其中右序列由转换后的元素构成。&lt;br&gt;这里有个地方需要引起注意：&lt;code&gt;[0, 1, 2] + [4]&lt;/code&gt; 执行速度要慢于 &lt;code&gt;[0, 1, 2].append(4)&lt;/code&gt;。倘若你正在处理庞大的列表，应取代集合 + 集合的方式，转而使用一个可变的 accumulator 变量进行递增：&lt;br&gt;    funcrmap(elements: [Int], transform: (Int) -&amp;gt; Int) -&amp;gt; [Int] {&lt;br&gt;    return elements.reduce(&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;, combine: { (var ac: [Int], b: Int) -&amp;gt; [Int] in&lt;br&gt;    // 作者提倡使用这种，因为执行速度更快&lt;br&gt;        ac.append(transform(b))&lt;br&gt;    return ac&lt;br&gt;        })&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;为了进一步加深对 &lt;code&gt;reduce&lt;/code&gt; 的理解，我们将继续重新实现 &lt;code&gt;flatMap&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt; 方法。&lt;br&gt;    funcrflatMap(elements: [Int], transform: (Int) -&amp;gt; Int?) -&amp;gt; [Int] {&lt;br&gt;    return elements.reduce(&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;,&lt;br&gt;           combine: { guardlet m = transform($1) else { return $0 }&lt;br&gt;    return $0 + [m]})&lt;br&gt;    }&lt;br&gt;    print(rflatMap([1, 3, 4], transform: { guard $0 != 3else { returnnil }; return $0 * 2}))&lt;br&gt;    // [2, 8]&lt;/p&gt;
&lt;p&gt;这里 rflatMap 和 rmap 主要差异在于，前者增加了一个 &lt;code&gt;guard&lt;/code&gt; 表达式确保可选类型始终有值（换言之，摒弃那些 nil 的情况）。&lt;/p&gt;
&lt;p&gt;###Filter&lt;br&gt;    funcrFilter(elements: [Int], filter: (Int) -&amp;gt; Bool) -&amp;gt; [Int] {&lt;br&gt;    return elements.reduce(&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;,&lt;br&gt;           combine: { guardfilter($1) else { return $0 }&lt;br&gt;    return $0 + [$1]})&lt;br&gt;    }&lt;br&gt;    print(rFilter([1, 3, 4, 6], filter: { $0 % 2 == 0}))&lt;br&gt;    // [4, 6]&lt;/p&gt;
&lt;p&gt;依旧难度不大。我们再次使用 guard 表达式确保满足筛选条件。&lt;br&gt;到目前为止，&lt;code&gt;reduce&lt;/code&gt; 方法看起来更像是 &lt;code&gt;map&lt;/code&gt; 或 &lt;code&gt;filter&lt;/code&gt; 的复杂版本，除此之外然并卵。不过，所结合的内容不需要是一个数组，它可以是其他任何类型。这使得我们依靠一种简单的方式，就可以轻松地实现各种 reduction 操作。&lt;/p&gt;
&lt;p&gt;###Reduce 范例&lt;br&gt;首先介绍我最喜欢的数组元素求和范例：&lt;br&gt;    // 初始值 initial 为 0，每次遍历数组元素，执行 + 操作&lt;br&gt;    [0, 1, 2, 3, 4].reduce(0, combine: +)&lt;br&gt;    // 10&lt;/p&gt;
&lt;p&gt;仅传入 &lt;code&gt;+&lt;/code&gt; 作为一个 &lt;code&gt;combinator&lt;/code&gt; 函数是有效的，它仅仅是对 &lt;code&gt;lhs（Left-hand side，等式左侧）&lt;/code&gt; 和&lt;code&gt;rhs（Right-hand side，等式右侧）&lt;/code&gt; 做加法处理，最后返回结果值，这完全满足 &lt;code&gt;reduce&lt;/code&gt; 函数的要求。&lt;br&gt;另外一个范例：通过一组数字计算他们的乘积：&lt;br&gt;    // 初始值 initial 为 1，每次遍历数组元素，执行 &lt;em&gt; 操作&lt;br&gt;    [1, 2, 3, 4].reduce(1, combine: &lt;/em&gt;)&lt;br&gt;    // 24&lt;/p&gt;
&lt;p&gt;甚至我们可以反转数组：&lt;br&gt;    // $0 指累加器（accumulator），$1 指遍历数组得到的一个元素&lt;br&gt;    [1, 2, 3, 4, 5].reduce(&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;, combine: { [$1] + $0 })&lt;br&gt;    // 5, 4, 3, 2, 1&lt;/p&gt;
&lt;p&gt;最后，来点有难度的任务。我们想要基于某个标准对列表做划分（Partition）处理：&lt;br&gt;    // 为元组定义个别名，此外 Acc 也是闭包传入的 accumulator 的类型&lt;br&gt;    typealiasAcc = (l: [Int], r: [Int])&lt;br&gt;    funcpartition(lst: [Int], criteria: (Int) -&amp;gt; Bool) -&amp;gt; Acc {&lt;br&gt;    return lst.reduce((l: &lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;, r: &lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;), combine: { (ac: Acc, o: Int) -&amp;gt; Accin&lt;br&gt;    if criteria(o) {&lt;br&gt;    return (l: ac.l + [o], r: ac.r)&lt;br&gt;          } else {&lt;br&gt;    return (r: ac.r + [o], l: ac.l)&lt;br&gt;          }&lt;br&gt;       })&lt;br&gt;    }&lt;br&gt;    partition([1, 2, 3, 4, 5, 6, 7, 8, 9], criteria: { $0 % 2 == 0 })&lt;br&gt;    //: ([2, 4, 6, 8], [1, 3, 5, 7, 9])&lt;/p&gt;
&lt;p&gt;上面实现中最有意思的莫过于我们使用 &lt;code&gt;tuple&lt;/code&gt; 作为 accumulator。你会渐渐发现，一旦你尝试将 &lt;code&gt;reduce&lt;/code&gt; 进入到日常工作流中，&lt;code&gt;tuple&lt;/code&gt; 是一个不错的选择，它能够将数据与 reduce 操作快速挂钩起来。&lt;/p&gt;
&lt;p&gt;###执行效率对比：Reduce vs. 链式结构&lt;br&gt;&lt;code&gt;reduce&lt;/code&gt; 除了较强的灵活性之外，还具有另一个优势：通常情况下，&lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt; 所组成的链式结构会引入性能上的问题，因为它们需要多次遍历你的集合才能最终得到结果值，这种操作往往伴随着性能损失，比如以下代码：&lt;br&gt;    [0, 1, 2, 3, 4].map({ $0 + 3}).filter({ $0 % 2 == 0}).reduce(0, combine: +)&lt;/p&gt;
&lt;p&gt;除了毫无意义之外，它还浪费了 CPU 周期。初始序列（即 [0, 1, 2, 3, 4]）被重复访问了三次之多。首先是 map，接着 filter，最后对数组内容求和。其实，所有这一切操作我们能够使用 &lt;code&gt;reduce&lt;/code&gt; 完全替换实现，极大提高执行效率：&lt;br&gt;    // 这里只需要遍历 1 次序列足矣&lt;br&gt;    [0, 1, 2, 3, 4].reduce(0, combine: { (ac: Int, r: Int) -&amp;gt; Intin&lt;br&gt;    if (r + 3) % 2 == 0 {&lt;br&gt;    return ac + r + 3&lt;br&gt;       } else {&lt;br&gt;    return ac&lt;br&gt;       }&lt;br&gt;    })&lt;/p&gt;
&lt;p&gt;这里给出一个快速的基准运行测试，使用以上两个版本以及 for-loop 方式对一个容量为 100000 的列表做处理操作：&lt;br&gt;    // for-loop 版本&lt;br&gt;    var ux = 0&lt;br&gt;    for i inArray(0…100000) {&lt;br&gt;    if (i + 3) % 2 == 0 {&lt;br&gt;        ux += (i + 3)&lt;br&gt;        }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://7xiol9.com1.z0.glb.clouddn.com/pic%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png&quot; title=&quot;测试结果&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://7xiol9.com1.z0.glb.clouddn.com/pic%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;测试结果&quot;&gt;&lt;/a&gt;测试结果&lt;br&gt;正如你所看见的，&lt;code&gt;reduce&lt;/code&gt; 版本的执行效率和 &lt;code&gt;for-loop&lt;/code&gt; 操作非常相近，且是链式操作的一半时间。&lt;br&gt;不过，在某些情况中，链式操作是优于 &lt;code&gt;reduce&lt;/code&gt; 的。思考如下范例：&lt;br&gt;    Array(0…100000).map({ $0 + 3}).reverse().prefix(3)&lt;br&gt;    // 0.027 Seconds&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array(0...100000).reduce([], combine: { (var ac: [Int], r: Int) -&amp;gt; [Int] in
    ac.insert(r + 3, atIndex: 0)
return ac
}).prefix(3)
// 2.927 Seconds
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里，注意到使用链式操作花费 0.027s，这与 reduce 操作的 2.927s 形成了鲜明的反差，这究竟是怎么回事呢？&lt;a href=&quot;http://swift.gg/2015/12/10/reduce-all-the-things/#2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2&lt;/a&gt;&lt;br&gt;Reddit 网站的搜索结果指出，从 reduce 的语义上来说，传入闭包的参数（如果可变的话，即 mutated），会对底层序列的每个元素都产生一份 copy 。在我们的案例中，这意味着 accumulator 参数 &lt;code&gt;ac&lt;/code&gt; 将为 0…100000 范围内的每个元素都执行一次复制操作。有关对此更好、更详细的解释请看这篇 &lt;a href=&quot;http://airspeedvelocity.net/2015/08/03/arrays-linked-lists-and-performance/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Airspeedvelocity&lt;/a&gt; 博客文章。&lt;br&gt;因此，当我们试图使用 &lt;code&gt;reduce&lt;/code&gt; 来替换掉一组操作时，请时刻保持清醒，问问自己：reduction 在问题中的情形下是否确实是最合适的方式。&lt;br&gt;现在，可以回到我们的初始问题：计算人口总数和平均年龄。请试着用 &lt;code&gt;reduce&lt;/code&gt; 来解决吧。&lt;/p&gt;
&lt;p&gt;###再一次尝试来写 infoFromState 函数&lt;/p&gt;
&lt;p&gt;###&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func infoFromState(state state: String, persons: [[String: AnyObject]]) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      -&amp;gt; (count: Int, age: Float) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 在函数内定义别名让函数更加简洁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      typealias Acc = (count: Int, age: Float)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// reduce 结果暂存为临时的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      let u = persons.reduce((count: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  (ac: Acc, p) -&amp;gt; Acc &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;span class=&quot;comment&quot;&gt;// 获取地区和年龄&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          guard let personState = p[&lt;span class=&quot;string&quot;&gt;&quot;city&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                personAge = p[&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 确保选出来的是来自正确的洲&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                where personState.hasSuffix(state)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;comment&quot;&gt;// 如果缺失年龄或者地区，又或者上者比较结果不等，返回&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ac &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;span class=&quot;comment&quot;&gt;// 最终累加计算人数和年龄&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (count: ac.count + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, age: ac.age + Float(personAge))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 我们的结果就是上面的人数和除以人数后的平均年龄&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (age: u.age / Float(u.count), count: u.count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(infoFromState(state: &lt;span class=&quot;string&quot;&gt;&quot;CA&quot;&lt;/span&gt;, persons: persons))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// prints: (count: 3, age: 34.3333)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###和早前的范例一样，我们再次使用了 &lt;code&gt;tuple&lt;/code&gt; 作为 accumulator 记录状态值。除此之外，代码读起来简明易懂。&lt;br&gt;同时，我们在函数体中定义了一个别名 Acc：&lt;code&gt;typealias Acc = (count: Int, age: Float)&lt;/code&gt;，起到了简化类型注释的作用。&lt;/p&gt;
&lt;p&gt;###总结&lt;br&gt;本文是对 &lt;code&gt;reduce&lt;/code&gt; 方法的一个简短概述。倘若你不想将过多函数式方法通过链式结构串联起来调用，亦或是数据的输出形式与传入数据的形式不一致时，reduce 就相当有用了。最后，我将向你展示通过使用 reduce 的各种范例来结束本文，希望能为你带来些许灵感。&lt;/p&gt;
&lt;p&gt;###更多范例&lt;br&gt;以下范例展示了 &lt;code&gt;reduce&lt;/code&gt; 的其他使用案例。请记住例子只作为展示教学使用，即它们更多地强调 reduce 的使用方式，而非为你的代码库提供通用的解决方法。大多数范例都可以通过其他更好、更快的方式来编写（即通过 extension 或 generics）。并且这些实现方式已经在许多 Swift 库中都有实现，诸如 &lt;a href=&quot;https://github.com/oisdk/SwiftSequence&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwiftSequence&lt;/a&gt; 以及 &lt;a href=&quot;https://github.com/ankurp/Dollar.swift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dollar.swift&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###Minimum&lt;br&gt;返回列表中的最小项。显然，&lt;code&gt;[1, 5, 2, 9, 4].minElement()&lt;/code&gt; 方法更胜一筹。&lt;br&gt;    // 初始值为 Int.max，传入闭包为 min：求两个数的最小值&lt;br&gt;    // min 闭包传入两个参数：1. 初始值 2. 遍历列表时的当前元素&lt;br&gt;    // 倘若当前元素小于初始值，初始值就会替换成当前元素&lt;br&gt;    // 示意写法： initial = min(initial, elem)&lt;br&gt;    [1, 5, 2, 9, 4].reduce(Int.max, combine: min)&lt;/p&gt;
&lt;p&gt;###Unique&lt;br&gt;剔除列表中重复的元素。当然，最好的解决方式是使用&lt;code&gt;集合（Set）&lt;/code&gt;。&lt;br&gt;    [1, 2, 5, 1, 7].reduce([], combine: { (a: [Int], b: Int) -&amp;gt; [Int] in&lt;br&gt;    if a.contains(b) {&lt;br&gt;    return a&lt;br&gt;    } else {&lt;br&gt;    return a + [b]&lt;br&gt;    }&lt;br&gt;    })&lt;br&gt;    // prints: 1, 2, 5, 7&lt;/p&gt;
&lt;p&gt;###Group By&lt;br&gt;遍历整个列表，通过一个鉴别函数对列表中元素进行分组，将分组后的列表作为结果值返回。问题中的鉴别函数返回值类型需要遵循 &lt;code&gt;Hashable&lt;/code&gt; 协议，这样我们才能拥有不同的键值。此外保留元素的排序，而组内元素排序则不一定被保留下来。&lt;br&gt;    funcgroupby&lt;t, h:=&quot;&quot; hashable=&quot;&quot;&gt;(items: [T], f: (T) -&amp;gt; H) -&amp;gt; [H: [T]] {&lt;br&gt;    return items.reduce([:], combine: { (var ac: [H: [T]], o: T) -&amp;gt; [H: [T]] in&lt;br&gt;    // o 为遍历序列的当前元素&lt;br&gt;    let h = f(o) // 通过 f 函数得到 o 对应的键值&lt;br&gt;    ifvarc = ac[h] { // 说明 o 对应的键值已经存在，只需要更新键值对应的数组元素即可&lt;br&gt;    c.append(o)&lt;br&gt;           ac.updateValue(c, forKey: h)&lt;br&gt;           } else { // 说明 o 对应的键值不存在，需要为字典新增一个键值，对应值为 [o]&lt;br&gt;           ac.updateValue([o], forKey: h)&lt;br&gt;           }&lt;br&gt;    return ac&lt;br&gt;       })&lt;br&gt;    }&lt;br&gt;    print(groupby([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], f: { $0 % 3 }))&lt;br&gt;    // prints: [2: [2, 5, 8, 11], 0: [3, 6, 9, 12], 1: [1, 4, 7, 10]]&lt;br&gt;    print(groupby([“Carl”, “Cozy”, “Bethlehem”, “Belem”, “Brand”, “Zara”], f: { $0.characters.first! }))&lt;br&gt;    // prints: [“C” : [“Carl” , “Cozy”] , “B” : [“Bethlehem” , “Belem” , “Brand”] , “Z” : [“Zara”]]&lt;/t,&gt;&lt;/p&gt;
&lt;p&gt;###Interpose&lt;br&gt;函数给定一个 &lt;code&gt;items&lt;/code&gt; 数组，每隔 &lt;code&gt;count&lt;/code&gt; 个元素插入 &lt;code&gt;element&lt;/code&gt; 元素，返回结果值。下面的实现确保了 element 仅在中间插入，而不会添加到数组尾部。&lt;br&gt;    funcinterpose&lt;t&gt;(items: [T], element: T, count: Int = 1) -&amp;gt; [T] {&lt;br&gt;    // cur 为当前遍历元素的索引值 cnt 为计数器，当值等于 count 时又重新置 1&lt;br&gt;    typealiasAcc = (ac: [T], cur: Int, cnt: Int)&lt;br&gt;    return items.reduce((ac: [], cur: 0, cnt: 1), combine: { (a: Acc, o: T) -&amp;gt; Accin&lt;br&gt;    switch a {&lt;br&gt;    // 此时遍历的当前元素为序列中的最后一个元素&lt;br&gt;    caselet (ac, cur, _) where (cur+1) == items.count: return (ac + [o], 0, 0)&lt;br&gt;    // 满足插入条件&lt;br&gt;    caselet (ac, cur, c) wherec == count:&lt;br&gt;    return (ac + [o, element], cur + 1, 1)&lt;br&gt;    // 执行下一步&lt;br&gt;    caselet (ac, cur, c):&lt;br&gt;    return (ac + [o], cur + 1, c + 1)&lt;br&gt;           }&lt;br&gt;       }).ac&lt;br&gt;    }&lt;br&gt;    print(interpose([1, 2, 3, 4, 5], element: 9))&lt;br&gt;    // : [1, 9, 2, 9, 3, 9, 4, 9, 5]&lt;br&gt;    print(interpose([1, 2, 3, 4, 5], element: 9, count: 2))&lt;br&gt;    // : [1, 2, 9, 3, 4, 9, 5]&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;###Interdig&lt;br&gt;该函数允许你有选择从两个序列中挑选元素合并成为一个新序列返回。&lt;br&gt;    funcinterdig&lt;t&gt;(list1: [T], list2: [T]) -&amp;gt; [T] {&lt;br&gt;    // Zip2Sequence 返回 [(list1, list2)] 是一个数组，类型为元组&lt;br&gt;    // 也就解释了为什么 combinator 闭包的类型是 (ac: [T], o: (T, T)) -&amp;gt; [T]&lt;br&gt;    returnZip2Sequence(list1, list2).reduce([], combine: { (ac: [T], o: (T, T)) -&amp;gt; [T] in&lt;br&gt;    return ac + [o.0, o.1]&lt;br&gt;       })&lt;br&gt;    }&lt;br&gt;    print(interdig([1, 3, 5], list2: [2, 4, 6]))&lt;br&gt;    // : [1, 2, 3, 4, 5, 6]&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;###Chunk&lt;br&gt;该函数返回原数组分解成长度为 &lt;code&gt;n&lt;/code&gt; 后的多个数组：&lt;br&gt;    funcchunk&lt;t&gt;(list: [T], length: Int) -&amp;gt; [[T]] {&lt;br&gt;    typealiasAcc = (stack: [[T]], cur: [T], cnt: Int)&lt;br&gt;    let l = list.reduce((stack: [], cur: [], cnt: 0), combine: { (ac: Acc, o: T) -&amp;gt; Accin&lt;br&gt;    if ac.cnt == length {&lt;br&gt;    return (stack: ac.stack + [ac.cur], cur: [o], cnt: 1)&lt;br&gt;          } else {&lt;br&gt;    return (stack: ac.stack, cur: ac.cur + [o], cnt: ac.cnt + 1)&lt;br&gt;          }&lt;br&gt;       })&lt;br&gt;    return l.stack + [l.cur]&lt;br&gt;    }&lt;br&gt;    print(chunk([1, 2, 3, 4, 5, 6, 7], length: 2))&lt;br&gt;    // : [[1, 2], [3, 4], [5, 6], [7]]&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;函数中使用一个更为复杂的 &lt;code&gt;accumulator&lt;/code&gt;，包含了 stack、current list 以及 count 。&lt;br&gt;译者注：有关 Reduce 底层实现，请看&lt;a href=&quot;http://www.jianshu.com/p/06c90c0470b2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原文 &lt;a href=&quot;http://swift.gg/2015/12/10/reduce-all-the-things/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://swift.gg/2015/12/10/reduce-all-the-things/&lt;/a&gt;&lt;br&gt;我修改了原文一些由于swift版本变化二导致的一些错误代码，现在能兼容swift2.2&lt;/p&gt;
</content>
    
    <summary type="html">
    
       Swift化零为整：Reduce 详解 
    
    </summary>
    
      <category term="Swift" scheme="http://offbye.com/categories/Swift/"/>
    
      <category term="reduce" scheme="http://offbye.com/categories/Swift/reduce/"/>
    
    
  </entry>
  
</feed>
